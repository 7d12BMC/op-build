From aaeb72ec680f77eaa8d583b9bd91b62745d025c7 Mon Sep 17 00:00:00 2001
From: Olsen <cmolsen@us.ibm.com>
Date: Thu, 6 Feb 2020 08:48:34 -0500
Subject: [PATCH] Mvpd-Ekb ringId gap-discontinuity support

Making support for the ringId gap that needs to exist between the end
of the Mvpd RingID group and the beginning of the Ekb RingID group
in order to be able to append Mvpd rings to the end of the Mvpd
RingID group without affecting the already assigned RingID enum for
any of the other existing rings.

Note that the purpose of any RingID grouping, or order, is to:
- ease debugging the ring images and output traces of ipl_customize,
- ease the maintaining of the ringId header files.

Enforcing ringId groups comes with an increase in code complexity
to enable conversion between ringId and rpIndex (i.e., the index of
of the RING_PROPERTIES list).

Several bugs were found in implementing the above support as there has
been a built-in assumption in the PPE/Cronus customized putRingUtils
and ring_traverse codes that the ringId is a uint8 type but which we
are now exceeding the limit of with this group enforcement.

Also added updated mvpd.dat, based on scandef ver 910007, to better
match EKB engd's version (which at the time of this merge seems to be
consistent with 910007).
- Also added an README file with details about mvpd.dat

Key_Cronus_Test=XIP_REGRESS_SBE_QME

Change-Id: I59eddeff34c3dedf23b092b0cf89ef422e8bb753
Reviewed-on: http://rchgit01.rchland.ibm.com/gerrit1/91255
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: PPE CI <ppe-ci+hostboot@us.ibm.com>
Tested-by: Cronus HW CI <cronushw-ci+hostboot@us.ibm.com>
Reviewed-by: Jennifer A Stofer <stofer@us.ibm.com>
---
 .../chips/common/utils/imageProcs/common_ringId.C  | 361 +++++-----
 .../chips/common/utils/imageProcs/common_ringId.H  |  34 +-
 .../procedures/hwp/accessors/p10_get_mvpd_ring.C   |   6 +-
 .../procedures/hwp/accessors/p10_mvpd_ring_funcs.C |  42 +-
 .../procedures/hwp/customize/p10_ipl_customize.C   | 282 ++++----
 .../procedures/hwp/customize/p10_qme_customize.C   | 281 ++++----
 .../procedures/hwp/customize/p10_qme_customize.H   |  67 +-
 .../p10/procedures/hwp/pm/p10_hcode_image_build.C  |   6 +-
 .../xml/error_info/p10_qme_customize_errors.xml    |  52 +-
 src/import/chips/p10/utils/imageProcs/p10_ringId.H |  48 +-
 .../chips/p10/utils/imageProcs/p10_ring_id.H       | 194 +++---
 .../p10/utils/imageProcs/p10_ring_properties.H     | 725 +++++++++++----------
 src/import/chips/p10/utils/imageProcs/p10_tor.C    |  75 ++-
 13 files changed, 1107 insertions(+), 1066 deletions(-)

diff --git a/src/import/chips/common/utils/imageProcs/common_ringId.C b/src/import/chips/common/utils/imageProcs/common_ringId.C
index 19729ad..904cb38 100644
--- a/src/import/chips/common/utils/imageProcs/common_ringId.C
+++ b/src/import/chips/common/utils/imageProcs/common_ringId.C
@@ -164,19 +164,22 @@ int ringid_get_scanScomAddr( ChipId_t   i_chipId,
     int rc = INFRASTRUCT_RC_SUCCESS;
     uint32_t l_scanScomAddr = UNDEFINED_SCOM_ADDR;
 
+    // Get the ring properties (rp) index
+    RingId_t rpIndex = P10_RID::ringid_convert_ringId_to_rpIndex(i_ringId);
+
     switch (i_chipId)
     {
         case CID_P10:
-            if (i_ringId >= P10_RID::NUM_RING_IDS)
+            if (rpIndex >= P10_RID::NUM_RING_IDS)
             {
-                MY_ERR("ringid_get_scanScomAddr(): ringId(=0x%x) >= NUM_RING_IDS(=0x%x) not"
-                       " allowed\n",
-                       i_ringId, P10_RID::NUM_RING_IDS);
+                MY_ERR("ringid_get_scanScomAddr(): rpIndex(=0x%x) >= NUM_RING_IDS(=0x%x) not"
+                       " allowed and ringId=0x%x\n",
+                       rpIndex, P10_RID::NUM_RING_IDS, i_ringId);
                 rc = TOR_INVALID_RING_ID;
                 break;
             }
 
-            l_scanScomAddr = P10_RID::RING_PROPERTIES[i_ringId].scanScomAddr;
+            l_scanScomAddr = P10_RID::RING_PROPERTIES[rpIndex].scanScomAddr;
             break;
 
         default:
@@ -198,18 +201,22 @@ int ringid_get_ringClass( ChipId_t      i_chipId,
     int rc = INFRASTRUCT_RC_SUCCESS;
     RingClass_t l_ringClass = UNDEFINED_RING_CLASS;
 
+    // Get the ring properties (rp) index
+    RingId_t rpIndex = P10_RID::ringid_convert_ringId_to_rpIndex(i_ringId);
+
     switch (i_chipId)
     {
         case CID_P10:
-            if (i_ringId >= P10_RID::NUM_RING_IDS)
+            if (rpIndex >= P10_RID::NUM_RING_IDS)
             {
-                MY_ERR("ringid_get_ringClass(): ringId(=0x%x) >= NUM_RING_IDS(=0x%x) not allowed\n",
-                       i_ringId, P10_RID::NUM_RING_IDS);
+                MY_ERR("ringid_get_ringClass(): rpIndex(=0x%x) >= NUM_RING_IDS(=0x%x) not"
+                       " allowed and ringId=0x%x\n",
+                       rpIndex, P10_RID::NUM_RING_IDS, i_ringId);
                 rc = TOR_INVALID_RING_ID;
                 break;
             }
 
-            l_ringClass = P10_RID::RING_PROPERTIES[i_ringId].ringClass;
+            l_ringClass = P10_RID::RING_PROPERTIES[rpIndex].ringClass;
             break;
 
         default:
@@ -227,33 +234,33 @@ int ringid_get_ringClass( ChipId_t      i_chipId,
 int ringid_check_ringId( ChipId_t  i_chipId,
                          RingId_t  i_ringId )
 {
-    int rc = INFRASTRUCT_RC_SUCCESS;
+    if ( i_ringId == HOLE_RING_ID )
+    {
+        // A hole ring is benign. Let caller decide.
+        return TOR_HOLE_RING_ID;
+    }
+
+    // Get the ring properties (rp) index
+    RingId_t rpIndex = P10_RID::ringid_convert_ringId_to_rpIndex(i_ringId);
 
     switch (i_chipId)
     {
         case CID_P10:
-            if ( strcmp(P10_RID::RING_PROPERTIES[i_ringId].ringName, "invalid") == 0 )
+            if ( rpIndex >= P10_RID::NUM_RING_IDS )
             {
-                // There are ringId holes. This is harmless. No trace out.
-                rc = TOR_HOLE_RING_ID;
-            }
-            else if ( i_ringId >= P10_RID::NUM_RING_IDS && i_ringId != UNDEFINED_RING_ID )
-            {
-                // This is unlikely to happen, and shouldn't happen, so here we trace out.
-                MY_ERR("ringid_check_ringId(): ringId(=0x%x) >= NUM_RING_IDS(=0x%x) not allowed\n",
-                       i_ringId, P10_RID::NUM_RING_IDS);
-                rc = TOR_INVALID_RING_ID;
+                // Not necessarily an error. Let caller decide.
+                return TOR_INVALID_RING_ID;
             }
 
             break;
 
         default:
-            MY_ERR("ringid_check_ringId(): Unsupported chipId (=%d) supplied\n", i_chipId);
-            rc = TOR_INVALID_CHIP_ID;
-            break;
+            MY_ERR("ERROR: ringid_check_ringId: Unsupported chipId(=0x%x) supplied\n",
+                   i_chipId);
+            return TOR_INVALID_CHIP_ID;
     }
 
-    return rc;
+    return TOR_SUCCESS;
 }
 
 
@@ -313,10 +320,21 @@ int ringid_get_chipletIndex( ChipId_t        i_chipId,
 MyBool_t ringid_is_mvpd_ring( ChipId_t  i_chipId,
                               RingId_t  i_ringId )
 {
+    // Get the ring properties (rp) index
+    RingId_t rpIndex = P10_RID::ringid_convert_ringId_to_rpIndex(i_ringId);
+
     switch (i_chipId)
     {
         case CID_P10:
-            if ( P10_RID::RING_PROPERTIES[i_ringId].ringClass & RCLS_MVPD_MASK )
+            if (rpIndex >= P10_RID::NUM_RING_IDS)
+            {
+                MY_ERR("ringid_is_mvpd_ring(): rpIndex(=0x%x) >= NUM_RING_IDS(=0x%x) not"
+                       " allowed and ringId=0x%x\n",
+                       rpIndex, P10_RID::NUM_RING_IDS, i_ringId);
+                return UNDEFINED_BOOLEAN;
+            }
+
+            if ( P10_RID::RING_PROPERTIES[rpIndex].ringClass & RCLS_MVPD_MASK )
             {
                 return true;
             }
@@ -325,6 +343,8 @@ MyBool_t ringid_is_mvpd_ring( ChipId_t  i_chipId,
                 return false;
             }
 
+            break;
+
         default:
             MY_ERR("ringid_is_mvpd_ring(): Unsupported chipId (=%d) supplied\n", i_chipId);
             return UNDEFINED_BOOLEAN;
@@ -336,10 +356,21 @@ MyBool_t ringid_is_mvpd_ring( ChipId_t  i_chipId,
 MyBool_t ringid_is_gptr_ring( ChipId_t  i_chipId,
                               RingId_t  i_ringId )
 {
+    // Get the ring properties (rp) index
+    RingId_t rpIndex = P10_RID::ringid_convert_ringId_to_rpIndex(i_ringId);
+
     switch (i_chipId)
     {
         case CID_P10:
-            if ( P10_RID::RING_PROPERTIES[i_ringId].ringClass & RMRK_GPTR_OVLY )
+            if (rpIndex >= P10_RID::NUM_RING_IDS)
+            {
+                MY_ERR("ringid_is_gptr_ring(): rpIndex(=0x%x) >= NUM_RING_IDS(=0x%x) not"
+                       " allowed and ringId=0x%x\n",
+                       rpIndex, P10_RID::NUM_RING_IDS, i_ringId);
+                return UNDEFINED_BOOLEAN;
+            }
+
+            if ( P10_RID::RING_PROPERTIES[rpIndex].ringClass & RMRK_GPTR_OVLY )
             {
                 return true;
             }
@@ -348,6 +379,8 @@ MyBool_t ringid_is_gptr_ring( ChipId_t  i_chipId,
                 return false;
             }
 
+            break;
+
         default:
             MY_ERR("ringid_is_gptr_ring(): Unsupported chipId (=%d) supplied\n", i_chipId);
             return UNDEFINED_BOOLEAN;
@@ -357,13 +390,51 @@ MyBool_t ringid_is_gptr_ring( ChipId_t  i_chipId,
 }
 
 
+MyBool_t ringid_is_instance_ring( RingId_t  i_rpIndex)
+{
+    if (i_rpIndex >= P10_RID::NUM_RING_IDS)
+    {
+        MY_ERR("ringid_is_instance_ring(): rpIndex(=0x%x) >= NUM_RING_IDS(=0x%x) not allowed\n",
+               i_rpIndex, P10_RID::NUM_RING_IDS);
+        return UNDEFINED_BOOLEAN;
+    }
+
+    if ( P10_RID::RING_PROPERTIES[i_rpIndex].idxRing == UNDEFINED_RING_INDEX )
+    {
+        return UNDEFINED_BOOLEAN;
+    }
+
+    if ( P10_RID::RING_PROPERTIES[i_rpIndex].idxRing & INSTANCE_RING_MARK )
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+
+    return UNDEFINED_BOOLEAN;
+}
+
+
 MyBool_t ringid_has_derivs( ChipId_t  i_chipId,
                             RingId_t  i_ringId )
 {
+    // Get the ring properties (rp) index
+    RingId_t rpIndex = P10_RID::ringid_convert_ringId_to_rpIndex(i_ringId);
+
     switch (i_chipId)
     {
         case CID_P10:
-            if ( P10_RID::RING_PROPERTIES[i_ringId].ringClass & RMRK_HAS_DERIVS )
+            if (rpIndex >= P10_RID::NUM_RING_IDS)
+            {
+                MY_ERR("ringid_has_derivs(): rpIndex(=0x%x) >= NUM_RING_IDS(=0x%x) not"
+                       " allowed and ringId=0x%x\n",
+                       rpIndex, P10_RID::NUM_RING_IDS, i_ringId);
+                return UNDEFINED_BOOLEAN;
+            }
+
+            if ( P10_RID::RING_PROPERTIES[rpIndex].ringClass & RMRK_HAS_DERIVS )
             {
                 return true;
             }
@@ -372,6 +443,8 @@ MyBool_t ringid_has_derivs( ChipId_t  i_chipId,
                 return false;
             }
 
+            break;
+
         default:
             MY_ERR("ringid_has_derivs(): Unsupported chipId (=%d) supplied\n", i_chipId);
             return UNDEFINED_BOOLEAN;
@@ -411,8 +484,9 @@ int ringidGetRootRingId( ChipId_t    i_chipId,
     int rc = INFRASTRUCT_RC_SUCCESS;
     RingProperties_t* ringProps = NULL;
     RingId_t          numRingIds = UNDEFINED_RING_ID;
-    RingId_t          iRingId = UNDEFINED_RING_ID; // ringId loop counter
-    RingId_t          l_ringId = UNDEFINED_RING_ID;
+    RingId_t          iRpIndex = UNDEFINED_RING_ID; // Ring properties index counter
+    RingId_t          rpIndexTmp = UNDEFINED_RING_ID; // Temporary RP index for bFound=true
+    RingId_t          l_ringId = UNDEFINED_RING_ID; // Local ringId, eventual output ringId
     bool              bFound = false;
 
     switch (i_chipId)
@@ -435,25 +509,26 @@ int ringidGetRootRingId( ChipId_t    i_chipId,
 
     if (!rc)
     {
-        for ( iRingId = 0; iRingId < numRingIds; iRingId++ )
+        for ( iRpIndex = 0; iRpIndex < numRingIds; iRpIndex++ )
         {
-            if ( ringProps[iRingId].scanScomAddr == i_scanScomAddr )
+            if ( ringProps[iRpIndex].scanScomAddr == i_scanScomAddr )
             {
-                if ( ringProps[iRingId].ringClass & RMRK_ROOT )
+                if ( ringProps[iRpIndex].ringClass & RMRK_ROOT )
                 {
                     if (bFound)
                     {
                         MY_ERR("ringidGetRootRingId(): Two rings w/same addr cannot both be"
                                " ROOT_RING.  Fix RING_PROPERTIES list for chipId=%d at"
                                " ringId=0x%x and ringId=0x%x\n",
-                               i_chipId, l_ringId, iRingId);
-                        rc = INFRASTRUCT_RC_CODE_BUG;
+                               i_chipId, rpIndexTmp, iRpIndex);
                         l_ringId = UNDEFINED_RING_ID;
+                        rc = INFRASTRUCT_RC_CODE_BUG;
                         break;
                     }
                     else
                     {
-                        l_ringId = iRingId;
+                        rpIndexTmp = iRpIndex;
+                        l_ringId = ringProps[iRpIndex].ringId;
                         bFound = true;
 
                         if (!i_bTest)
@@ -473,145 +548,6 @@ int ringidGetRootRingId( ChipId_t    i_chipId,
     {
         // This is not a bug, but do tell caller that scanScomAddr wasn't found.
         rc = TOR_SCOM_ADDR_NOT_FOUND;
-
-        if (l_ringId != UNDEFINED_RING_ID)
-        {
-            MY_ERR("ringidGetRootRingId(): Did not find match for scanScomAddr=0x%08x for"
-                   " chipId=%d.  However, l_ringId=0x%x cannot be different from"
-                   " UNDEFINED_RING_ID=0x%x.  Fix code!\n",
-                   i_scanScomAddr, i_chipId, l_ringId, UNDEFINED_RING_ID);
-            rc = INFRASTRUCT_RC_CODE_BUG;
-        }
-    }
-
-    o_ringId = l_ringId;
-
-    return rc;
-}
-
-
-int ringidGetRingId2( ChipId_t       i_chipId,
-                      uint32_t       i_torMagic,
-                      ChipletType_t  i_chipletType, // Ignored if only one chiplet in torMagic
-                      uint8_t        i_idxRing,     // The effective ring index within chiplet's
-                      // common or instance ring section
-                      MyBool_t       i_bInstCase,
-                      RingId_t&      o_ringId,
-                      bool           i_bTest )
-{
-    int rc = INFRASTRUCT_RC_SUCCESS;
-    ChipletType_t     l_chipletType = UNDEFINED_CHIPLET_TYPE;
-    RingProperties_t* ringProps = NULL;
-    RingId_t          numRingIds = UNDEFINED_RING_ID;
-    RingId_t          iRingId = UNDEFINED_RING_ID; // ringId loop counter
-    RingId_t          l_ringId = UNDEFINED_RING_ID;
-    uint8_t           l_idxRing = UNDEFINED_RING_INDEX;
-    bool              bFound = false;
-    bool              bOverlap = false;
-
-    // First, select the main ring list we need. And while we're at it,
-    // convert input chipletType, which can be ignored for ring sections (i.e. torMagic)
-    // with only one chiplet, to a valid chipletType
-    switch (i_chipId)
-    {
-        case CID_P10:
-            ringProps = (RingProperties_t*)&P10_RID::RING_PROPERTIES;
-            numRingIds = P10_RID::NUM_RING_IDS;
-
-            if ( i_torMagic == TOR_MAGIC_SBE  ||
-                 i_torMagic == TOR_MAGIC_OVRD ||
-                 i_torMagic == TOR_MAGIC_OVLY ||
-                 i_torMagic == TOR_MAGIC_DYN )
-            {
-                l_chipletType = i_chipletType;
-            }
-            else if ( i_torMagic == TOR_MAGIC_QME )
-            {
-                l_chipletType = P10_RID::EQ_TYPE;
-            }
-            else
-            {
-                MY_ERR("Invalid torMagic(=0x%08x) for chipId=CID_P10x=%d\n", i_torMagic, i_chipId);
-                return TOR_INVALID_MAGIC_NUMBER;
-            }
-
-            break;
-
-        default:
-            MY_ERR("ringidGetRingId2(): Unsupported chipId (=%d) supplied\n", i_chipId);
-            rc = TOR_INVALID_CHIP_ID;
-            break;
-    }
-
-    // Second, convert effective input ring index (which has no instance marker) to the
-    // common/instance specific index
-    l_idxRing = i_bInstCase ?
-                i_idxRing | INSTANCE_RING_MARK :
-                i_idxRing;
-
-    if (!rc)
-    {
-        for ( iRingId = 0; iRingId < numRingIds; iRingId++ )
-        {
-            if ( ringProps[iRingId].chipletType == l_chipletType &&
-                 ringProps[iRingId].idxRing == l_idxRing )
-            {
-                if (bFound)
-                {
-                    // Allow ring index overlap between a root and a non-root ring
-                    // and let the non-root (i.e., the bucket ring) "win"
-                    if ( !bOverlap &&
-                         ( (ringProps[iRingId].ringClass & RMRK_ROOT) !=
-                           (ringProps[l_ringId].ringClass & RMRK_ROOT) ) )
-                    {
-                        if ( !(ringProps[iRingId].ringClass & RMRK_ROOT) )
-                        {
-                            l_ringId = iRingId;
-                        }
-                        else
-                        {
-                            // Keep l_ringId as is since it must already be the non-root ring
-                        }
-
-                        bOverlap = true; // Indicate we found an overlap match
-
-                        if (!i_bTest)
-                        {
-                            // Stop testing and break our of ringId loop
-                            break;
-                        }
-                    }
-                    else
-                    {
-                        MY_ERR("ringidGetRingId2(): Two root, or two non-root, rings within a"
-                               " chiplet (chipletType=%d) cannot have the same ring index"
-                               " (idxRing=%d, bInst=%d). Fix RING_PROPERTIES list for chipId=%d"
-                               " at ringId=0x%x and ringId=0x%x\n",
-                               l_chipletType, i_idxRing, i_bInstCase, i_chipId, l_ringId, iRingId);
-                        rc = INFRASTRUCT_RC_CODE_BUG;
-                        l_ringId = UNDEFINED_RING_ID;
-                        break;
-                    }
-                }
-                else
-                {
-                    l_ringId = iRingId;
-                    bFound = true; // Indicate we found a first match
-
-                    // Continue searching for ring index overlap due to bucket ring or code bug
-                }
-            }
-        }
-    }
-
-    if (!rc && !bFound)
-    {
-        MY_ERR("ringidGetRingId2(): Could not find a match for (chipId,chipletType,idxRing,bInst) ="
-               " (%d, %d, %d, %d).  Fix RING_PROPERTIES list for chipId=%d (Note, l_ringId=0x%x"
-               " better be equal to UNDEFINED_RING_ID=0x%x)\n",
-               i_chipId, l_chipletType, i_idxRing, i_bInstCase,
-               i_chipId, l_ringId, UNDEFINED_RING_ID);
-        rc = INFRASTRUCT_RC_CODE_BUG;
     }
 
     o_ringId = l_ringId;
@@ -643,16 +579,20 @@ std::map <std::string, ChipId_t> chipTypeToIdMap
     { "explorer", (ChipId_t)CID_EXPLORER }
 };
 
+
+//
+// Get ringId from ringName
+//
 int ringidGetRingId1( ChipId_t     i_chipId,
                       std::string  i_ringName,
                       RingId_t&    o_ringId,
                       bool         i_bTest )
 {
-    int rc = INFRASTRUCT_RC_SUCCESS;
+    int rc = TOR_SUCCESS;
     RingProperties_t* ringProps = NULL;
     RingId_t          numRingIds = UNDEFINED_RING_ID;
-    RingId_t          iRingId = UNDEFINED_RING_ID; // ringId loop counter
-    RingId_t          l_ringId = UNDEFINED_RING_ID;
+    RingId_t          iRpIndex = UNDEFINED_RING_ID; // Ring properties index counter
+    RingId_t          rpIndex = UNDEFINED_RING_ID; // The matching RP index
     bool              bFound = false;
 
     switch (i_chipId)
@@ -668,24 +608,30 @@ int ringidGetRingId1( ChipId_t     i_chipId,
             break;
     }
 
-    if (!rc)
+    if (rc)
+    {
+        return rc;
+    }
+    else
     {
-        for ( iRingId = 0; iRingId < numRingIds; iRingId++ )
+        // Search through RING_PROPERTIES for ringName match
+        for ( iRpIndex = 0; iRpIndex < numRingIds; iRpIndex++ )
         {
-            if ( !(i_ringName.compare(ringProps[iRingId].ringName)) )
+            if ( !(i_ringName.compare(ringProps[iRpIndex].ringName)) )
             {
                 if (bFound)
                 {
-                    MY_ERR("ringidGetRingId1(): Two rings cannot have the same ringName=%s.  Fix"
-                           " RING_PROPERTIES list for chipId=%d at ringId=0x%x and ringId=0x%x\n",
-                           i_ringName.c_str(), i_chipId, l_ringId, iRingId);
-                    rc = INFRASTRUCT_RC_CODE_BUG;
-                    l_ringId = UNDEFINED_RING_ID;
+                    MY_ERR("ringidGetRingId1(): Two rings cannot have the same ringName=%s. Fix"
+                           " RING_PROPERTIES list for chipId=%d at rpIndex=0x%x and"
+                           " rpIndex=0x%x\n",
+                           i_ringName.c_str(), i_chipId, rpIndex, iRpIndex);
+                    rpIndex = UNDEFINED_RING_ID;
+                    rc = TOR_CODE_BUG;
                     break;
                 }
                 else
                 {
-                    l_ringId = iRingId;
+                    rpIndex = iRpIndex;
                     bFound = true;
 
                     if (!i_bTest)
@@ -700,39 +646,62 @@ int ringidGetRingId1( ChipId_t     i_chipId,
         }
     }
 
-    if (!rc && !bFound)
+    if (rc)
+    {
+        return rc;
+    }
+    else if (bFound)
+    {
+        o_ringId = ringProps[rpIndex].ringId;
+        rc = TOR_SUCCESS;
+    }
+    else
     {
-        MY_DBG("ringidGetRingId1(): Did not find match to ringName=%s for chipId=%d."
-               " (Note, l_ringId=0x%x better be equal to UNDEFINED_RING_ID=0x%x)\n",
-               i_ringName.c_str(), i_chipId, l_ringId, UNDEFINED_RING_ID);
+        MY_DBG("ringidGetRingId1(): Did not find match to ringName=%s for chipId=%u"
+               " (Note, rpIndex=0x%x better be equal to UNDEFINED_RING_ID=0x%x)\n",
+               i_ringName.c_str(), i_chipId, rpIndex, UNDEFINED_RING_ID);
+        o_ringId = UNDEFINED_RING_ID;
         rc = TOR_RING_NAME_NOT_FOUND;
     }
 
-    o_ringId = l_ringId;
-
     return rc;
 }
 
 
+//
+// Get ringName from ringId
+//
 int ringidGetRingName( ChipId_t     i_chipId,
                        RingId_t     i_ringId,
                        std::string& o_ringName )
 {
     int rc = INFRASTRUCT_RC_SUCCESS;
+    RingProperties_t* ringProps = (RingProperties_t*)&P10_RID::RING_PROPERTIES;
     std::string l_ringName;
 
+    // Get the ring properties (rp) index
+    RingId_t rpIndex = P10_RID::ringid_convert_ringId_to_rpIndex(i_ringId);
+
     switch (i_chipId)
     {
         case CID_P10:
-            if (i_ringId >= P10_RID::NUM_RING_IDS)
+            if (rpIndex >= P10_RID::NUM_RING_IDS)
             {
-                MY_ERR("ringidGetRingName(): ringId(=0x%x) >= NUM_RING_IDS(=0x%x) not allowed\n",
-                       i_ringId, P10_RID::NUM_RING_IDS);
+                MY_ERR("ringidGetRingName(): rpIndex(=0x%x) >= NUM_RING_IDS(=0x%x) not allowed"
+                       " and ringId=0x%x\n",
+                       rpIndex, P10_RID::NUM_RING_IDS, i_ringId);
                 rc = TOR_INVALID_RING_ID;
                 break;
             }
 
-            l_ringName = (std::string)P10_RID::RING_PROPERTIES[i_ringId].ringName;
+            l_ringName = (std::string)ringProps[rpIndex].ringName;
+
+            if (ringProps[rpIndex].ringId == HOLE_RING_ID)
+            {
+                rc = TOR_HOLE_RING_ID;
+                break;
+            }
+
             break;
 
         default:
diff --git a/src/import/chips/common/utils/imageProcs/common_ringId.H b/src/import/chips/common/utils/imageProcs/common_ringId.H
index 925c321..c2d0e59 100644
--- a/src/import/chips/common/utils/imageProcs/common_ringId.H
+++ b/src/import/chips/common/utils/imageProcs/common_ringId.H
@@ -52,6 +52,7 @@ typedef uint16_t  TorOffset_t;      // Type for offset value to various TOR obje
 typedef uint8_t   MyBool_t;         // false:0, true:1, undefined:UNDEFINED_BOOLEAN
 
 #define  UNDEFINED_RING_ID         (RingId_t)0xffff
+#define  HOLE_RING_ID              (RingId_t)0xeeee
 #define  UNDEFINED_SCOM_ADDR       (uint32_t)0xffffffff
 #define  UNDEFINED_RING_CLASS      (RingClass_t)0xffff
 #define  UNDEFINED_CHIPLET_TYPE    (ChipletType_t)0xff
@@ -222,11 +223,12 @@ enum RingMarker
     RMRK_TIME        = (RingClass_t)0b0000000000010000, // Time ring marker bit
     RMRK_MVPD_PDG    = (RingClass_t)0b0000000010000000, // MVPD #G gptr/time ring marker bit
     RMRK_MVPD_PDP    = (RingClass_t)0b0000000100000000, // MVPD #P pll ring marker bit
-    RMRK_MVPD_PDR    = (RingClass_t)0b0000001000000000, // MVPD #G repr ring marker bit
-    RMRK_MVPD_NEST   = (RingClass_t)0b0000010000000000, // NEST (non-EQ) ring marker bit
-    RMRK_MVPD_EQ     = (RingClass_t)0b0000100000000000, // EQ (non-core) ring marker bit
-    RMRK_MVPD_CORE   = (RingClass_t)0b0001000000000000, // Core ring marker bit
-    RMRK_SCAN_BY_QME = (RingClass_t)0b0010000000000000, // QME scannable ring marker bit
+    RMRK_MVPD_PDR    = (RingClass_t)0b0000001000000000, // MVPD #R repr ring marker bit
+    RMRK_MVPD_PDS    = (RingClass_t)0b0000010000000000, // MVPD #S dts ring marker bit
+    RMRK_MVPD_NEST   = (RingClass_t)0b0000100000000000, // NEST (non-EQ) ring marker bit
+    RMRK_MVPD_EQ     = (RingClass_t)0b0001000000000000, // EQ (non-core) ring marker bit
+    RMRK_MVPD_CORE   = (RingClass_t)0b0010000000000000, // Core ring marker bit
+    RMRK_SCAN_BY_QME = (RingClass_t)0b0100000000000000, // QME scannable ring marker bit
 };
 
 //
@@ -245,6 +247,9 @@ enum RingMarker
 #define RCLS_MVPD_PDR_NEST      (RMRK_MVPD_PDR | RMRK_MVPD_NEST)
 #define RCLS_MVPD_PDR_EQ        (RMRK_MVPD_PDR | RMRK_MVPD_EQ)
 #define RCLS_MVPD_PDR_CORE      (RMRK_MVPD_PDR | RMRK_MVPD_CORE)
+#define RCLS_MVPD_PDS_NEST      (RMRK_MVPD_PDS | RMRK_MVPD_NEST)
+#define RCLS_MVPD_PDS_EQ        (RMRK_MVPD_PDS | RMRK_MVPD_EQ)
+#define RCLS_MVPD_PDS_CORE      (RMRK_MVPD_PDS | RMRK_MVPD_CORE)
 // MVPD keyword mask
 #define RCLS_MVPD_MASK          (RMRK_MVPD_PDG | RMRK_MVPD_PDP | RMRK_MVPD_PDR)
 
@@ -273,6 +278,7 @@ enum RingRequest
 typedef struct
 {
 #ifndef __PPE__
+    RingId_t      ringId;
     char          ringName[MAX_RING_NAME_LENGTH];
     uint32_t      scanScomAddr;
 #endif
@@ -323,7 +329,7 @@ typedef struct
 #define TOR_INVALID_MAGIC_NUMBER              INFRASTRUCT_NOOF_RCS + 2
 #define TOR_INVALID_CHIP_ID                   INFRASTRUCT_NOOF_RCS + 3
 #define TOR_INVALID_CHIPLET_TYPE              INFRASTRUCT_NOOF_RCS + 4
-#define TOR_INVALID_RING_ID                   INFRASTRUCT_NOOF_RCS + 5
+#define TOR_INVALID_RING_ID                   INFRASTRUCT_NOOF_RCS + 5  // ringId falls outside Mvpd and Ekb range
 #define TOR_INVALID_CHIPLET_ID                INFRASTRUCT_NOOF_RCS + 6
 #define TOR_INVALID_RING_REQUEST              INFRASTRUCT_NOOF_RCS + 7
 #define TOR_UNSUPPORTED_RING_SECTION          INFRASTRUCT_NOOF_RCS + 8
@@ -341,7 +347,7 @@ typedef struct
 #define TOR_RING_NAME_NOT_FOUND               INFRASTRUCT_NOOF_RCS + 20
 #define TOR_NO_RINGS_FOR_CHIP                 INFRASTRUCT_NOOF_RCS + 21
 #define TOR_DYN_RING_NOT_FOUND                INFRASTRUCT_NOOF_RCS + 22
-#define TOR_HOLE_RING_ID                      INFRASTRUCT_NOOF_RCS + 23
+#define TOR_HOLE_RING_ID                      INFRASTRUCT_NOOF_RCS + 23 // ringId is a "hole" ring
 
 // This function returns the main ring properties list associated w/the chip ID.
 int ringid_get_ringProps( ChipId_t           i_chipId,
@@ -388,6 +394,9 @@ MyBool_t ringid_is_mvpd_ring( ChipId_t  i_chipId,
 MyBool_t ringid_is_gptr_ring( ChipId_t  i_chipId,
                               RingId_t  i_ringId );
 
+// Check if ring is a Common or Instance ring
+MyBool_t ringid_is_instance_ring( RingId_t  i_rpIndex);
+
 // Check if ring has derivative, eg if it has bucket rings. Note that the actual
 // derivative ring itself, eg the *_bucket_n ring, will *not* be marked as derivative.
 // Only the "root ring", eg that does *not* have the *_bucket_n suffix, will be marked.
@@ -425,17 +434,6 @@ int ringidGetRootRingId( ChipId_t   i_chipId,
                          RingId_t&  o_ringId,
                          bool       i_bTest = false );
 
-// This function returns the ringId associated with the effective ring index within a chiplet.
-// (Note that "effective" means the index is void of the instance marker bit.)
-int ringidGetRingId2( ChipId_t       i_chipId,
-                      uint32_t       i_torMagic,
-                      ChipletType_t  i_chipletType, // Ignored if only one chiplet in torMagic
-                      uint8_t        i_idxRing,     // The eEffective ring index within chiplet's
-                      // common or instance ring section
-                      MyBool_t       i_bInstCase,   // =0 common ring, =1 instance ring
-                      RingId_t&      o_ringId,
-                      bool           i_bTest = false );
-
 // This fumction returns the ringClass associated with the ringId.
 int ringidGetRingClass( ChipId_t      i_chipId,
                         RingId_t      i_ringId,
diff --git a/src/import/chips/p10/procedures/hwp/accessors/p10_get_mvpd_ring.C b/src/import/chips/p10/procedures/hwp/accessors/p10_get_mvpd_ring.C
index d439f9c..353fcf6 100644
--- a/src/import/chips/p10/procedures/hwp/accessors/p10_get_mvpd_ring.C
+++ b/src/import/chips/p10/procedures/hwp/accessors/p10_get_mvpd_ring.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2019                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2020                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -60,7 +60,7 @@ extern "C"
     {
         fapi2::ReturnCode        l_fapirc;
 
-        FAPI_DBG("getMvpdRing: Called w/ringId=0x%x, chipletSel=0x%8x, size=0x%x",
+        FAPI_DBG("getMvpdRing: Called w/ringId=0x%x, chipletSel=0x%08x and bufsize=0x%x",
                  i_ringId,
                  i_chipletSel,
                  io_rRingBufsize  );
@@ -76,7 +76,7 @@ extern "C"
                                  io_rRingBufsize );
 
 
-        FAPI_DBG("getMvpdRing: exit rc=0x%x",
+        FAPI_DBG("getMvpdRing: Exit w/rc=0x%08x",
                  static_cast<uint32_t>(l_fapirc) );
 
         return  l_fapirc;
diff --git a/src/import/chips/p10/procedures/hwp/accessors/p10_mvpd_ring_funcs.C b/src/import/chips/p10/procedures/hwp/accessors/p10_mvpd_ring_funcs.C
index be8b6ea..da74045 100644
--- a/src/import/chips/p10/procedures/hwp/accessors/p10_mvpd_ring_funcs.C
+++ b/src/import/chips/p10/procedures/hwp/accessors/p10_mvpd_ring_funcs.C
@@ -483,12 +483,10 @@ extern "C"
                 // found it, return pointer to ring
                 *o_pScanData = l_pScanData;
 
-                FAPI_DBG("mvpdRingFuncFindHdr: found RS4 ring for "
-                         "chipletSel 0x%08x and ringId %d "
-                         "at address 0x%x and with size %d",
+                FAPI_DBG("mvpdRingFuncFindHdr: Found RS4 ring for chipletSel=0x%08x and"
+                         " ringId=0x%x and ring size=%u",
                          i_chipletSel,
                          i_ringId,
-                         *o_pScanData,
                          be16toh((*o_pScanData)->iv_size));
             }
         }
@@ -552,20 +550,19 @@ extern "C"
         uint32_t            l_prevLen;
         uint32_t            l_recordBufLenLeft = i_recordBufLen;
 
-        FAPI_DBG("mvpdRingFuncFind: Called w/chipletSel=0x%08x, ringId=0x%x ",
+        FAPI_IMP("mvpdRingFuncFind: Enter w/chipletSel=0x%08x and ringId=0x%x ",
                  i_chipletSel,
                  i_ringId);
 
-        //  Find first RSA data block in ring (fixed offset defined by
-        //      MVPD spec)
+        //  Find first RSA data block in ring (fixed offset defined by MVPD spec)
         //
-        //  First byte in record should be the version number, skip
-        //      over this.
+        //  First byte in record's keyword is the version number which we skip
         //
-        FAPI_DBG( "mvpdRingFuncFind: record version = 0x%x", *i_pRecordBuf );
         i_pRecordBuf++;
         l_recordBufLenLeft--;
 
+        o_rRingLen = 0; // Just making sure this is zero in case of a fail or not found
+
         do
         {
             // let's track the previous size of the remaining buffer,
@@ -610,12 +607,6 @@ extern "C"
         {
             o_rpRing   = (uint8_t*)l_pScanData;
             o_rRingLen = be16toh(l_pScanData->iv_size);
-
-            // Dump record info for debug
-            FAPI_DBG("mvpdRingFuncFind:ringId=0x%x chipletSel=0x%08x size=0x%x",
-                     i_ringId,
-                     i_chipletSel,
-                     be16toh(l_pScanData->iv_size));
         }
         else
         {
@@ -629,13 +620,12 @@ extern "C"
         // get current error
         l_fapirc = fapi2::current_err;
 
-        FAPI_DBG("mvpdRingFuncFind: exit *ring= 0x%p", o_rpRing);
-        FAPI_IMP("mvpdRingFuncFind: exit chipletSel=0x%08x, ringId=0x%x size=0x%x"
-                 " rc=0x%x",
+        FAPI_IMP("mvpdRingFuncFind: Exit w/rc=0x%08x for chipletSel=0x%08x, ringId=0x%x and"
+                 " ring size=%u (if size==0, then something failed)",
+                 static_cast<uint32_t>(l_fapirc),
                  i_chipletSel,
                  i_ringId,
-                 o_rRingLen,
-                 static_cast<uint32_t>(l_fapirc) );
+                 o_rRingLen);
 
         return  l_fapirc;
     }
@@ -717,7 +707,7 @@ extern "C"
                      "Test0x80: iv_ringId=0x%x    vs  i_ringId=0x%x \n"
                      "Test0x80: iv_scanAddr=0x%x  vs  i_chipletSel=0x%08x \n"
                      "Test0x80: iv_size=0x%x      vs  i_ringBufsize=0x%x  vs  sizeof(CompressedScanData)=0x%x \n"
-                     "Fail test vector: 0x0x%02x",
+                     "Fail test vector: 0x%02x",
                      be16toh(i_pRingBuf->iv_magic), RS4_MAGIC,
                      be16toh(i_pRingBuf->iv_ringId), i_ringId,
                      be32toh(i_pRingBuf->iv_scanAddr), i_chipletSel,
@@ -779,7 +769,7 @@ extern "C"
             }
 
             //  we're good, copy data into the passed-in buffer
-            FAPI_DBG( "mvpdRingFuncGet: memcpy 0x%p 0x%p 0x%x",
+            FAPI_DBG( "mvpdRingFuncGet: memcpy(0x%p,0x%p,%u)",
                       i_pCallerRingBuf,
                       i_pRing,
                       i_ringLen );
@@ -824,9 +814,9 @@ extern "C"
             io_rCallerRingBufLen = i_ringLen;
         }
 
-        FAPI_DBG( "mvpdRingFuncGet: exit bufsize= 0x%x rc= 0x%x",
-                  io_rCallerRingBufLen,
-                  static_cast<uint32_t>(l_fapirc) );
+        FAPI_DBG( "mvpdRingFuncGet: Exit w/rc=0x%08x and w/bufsize=0x%x",
+                  static_cast<uint32_t>(l_fapirc),
+                  io_rCallerRingBufLen );
 
         return l_fapirc;
     }
diff --git a/src/import/chips/p10/procedures/hwp/customize/p10_ipl_customize.C b/src/import/chips/p10/procedures/hwp/customize/p10_ipl_customize.C
index f5f743b..eeb380b 100644
--- a/src/import/chips/p10/procedures/hwp/customize/p10_ipl_customize.C
+++ b/src/import/chips/p10/procedures/hwp/customize/p10_ipl_customize.C
@@ -44,7 +44,7 @@
 
 #include <p10_ipl_customize.H>
 #include <p10_ipl_image.H>
-#include <p10_ring_id.H>
+#include <p10_ringId.H>
 #include <p10_tor.H>
 #include <p10_scan_compression.H>
 #include <p10_infrastruct_help.H>
@@ -187,7 +187,7 @@ fapi2::ReturnCode writePG(
                      set_CHIP_UNIT_POS(l_unit_id).
                      set_PG_INDEX(l_pg_idx).
                      set_IMG_PG_ENTRIES(IMG_PG_ENTRIES),
-                     "Code bug: Invalid translation from PERV chip unit position"
+                     "CODE BUG: Invalid translation from PERV chip unit position"
                      " to image PG index: l_pg_idx=%d, IMG_PG_ENTRIES=%d",
                      l_pg_idx, IMG_PG_ENTRIES );
 
@@ -321,7 +321,7 @@ fapi_try_exit:
 // void*    io_rs4Ring:      Contains target RS4 ring on input and final overlaid RS4 ring on output
 // void*    io_workBuf:      Work buffer (has final overlaid raw ring on output)
 // void*    i_ovlyRawRing:   Raw data+care overlay ring
-// uint32_t i_ovlyRawSize:   Overlay raw ring size
+// uint32_t i_ovlyRawLength: Overlay raw ring bit length
 // CompressedScanData* i_rs4RefHdr:  Reference ring to get header data from (assumed volatile)
 // uint8_t  i_rs4TypeField:  iv_type to be used for final RS4 ring
 //
@@ -339,7 +339,7 @@ fapi2::ReturnCode apply_overlay_ring(
     void*    io_rs4Ring,
     void*    io_workBuf,
     void*    i_ovlyRawRing,
-    uint32_t i_ovlyRawSize,
+    uint32_t i_ovlyRawLength,
     CompressedScanData*  i_rs4RefHeader,
     uint8_t  i_rs4TypeField)
 {
@@ -351,11 +351,9 @@ fapi2::ReturnCode apply_overlay_ring(
     // Pt to our Target/Final raw work buffers
     uint8_t* dataTgt = (uint8_t*)io_workBuf;
     uint8_t* careTgt = (uint8_t*)io_workBuf + MAX_RING_BUF_SIZE / 2;
-    uint32_t tgtRawSize = 0;
+    uint32_t tgtRawLength = 0;
     MyBool_t bOvrd = UNDEFINED_BOOLEAN;
 
-    FAPI_DBG("Entering apply_overlay_ring");
-
     // Copy the key RS4 ref header settings into local struct before we, possibly,
     // contaminate i_rs4RefHeader as this may be pointing to one of our work
     // buffers.
@@ -365,12 +363,15 @@ fapi2::ReturnCode apply_overlay_ring(
     l_rs4RefHeader.iv_ringId = be16toh(i_rs4RefHeader->iv_ringId);
     l_rs4RefHeader.iv_scanAddr = be32toh(i_rs4RefHeader->iv_scanAddr);
 
+    FAPI_DBG("Entering apply_overlay_ring w/ringId=0x%0x and rawLength=%u",
+             l_rs4RefHeader.iv_ringId, i_ovlyRawLength);
+
     // Decompress the ring to apply overlay onto, io_rs4Ring.
     l_rc = _rs4_decompress(
                dataTgt,
                careTgt,
                MAX_RING_BUF_SIZE / 2, // Max allowable raw ring size (in bytes)
-               &tgtRawSize,         // Actual raw ring size (in bits) on return.
+               &tgtRawLength,         // Actual raw ring size (in bits) on return.
                (CompressedScanData*)io_rs4Ring );
 
     FAPI_ASSERT( l_rc == INFRASTRUCT_RC_SUCCESS,
@@ -385,13 +386,13 @@ fapi2::ReturnCode apply_overlay_ring(
                  l_rc, l_rs4RefHeader.iv_ringId, MAX_RING_BUF_SIZE );
 
     // Compare raw Target and Overlay raw ring lengths
-    FAPI_ASSERT( i_ovlyRawSize == tgtRawSize,
+    FAPI_ASSERT( i_ovlyRawLength == tgtRawLength,
                  fapi2::XIPC_TARGET_OVLY_RAW_RING_LENGTH_MISMATCH().
                  set_CHIP_TARGET(i_procTarget).
-                 set_TARGET_RAW_RING_LENGTH(tgtRawSize).
-                 set_OVLY_RAW_RING_LENGTH(i_ovlyRawSize),
+                 set_TARGET_RAW_RING_LENGTH(tgtRawLength).
+                 set_OVLY_RAW_RING_LENGTH(i_ovlyRawLength),
                  "ERROR: Target ring raw length(=%u) and overlay ring raw length(=%u) don't match.",
-                 tgtRawSize, i_ovlyRawSize);
+                 tgtRawLength, i_ovlyRawLength);
 
     // Check ring's iv_type is either override or flush
     bOvrd = rs4_is_ovrd(&l_rs4RefHeader);
@@ -413,7 +414,7 @@ fapi2::ReturnCode apply_overlay_ring(
     //
     uint32_t i, j;
 
-    for (i = 0; i < tgtRawSize / 8; i++)
+    for (i = 0; i < tgtRawLength / 8; i++)
     {
         if (careOvly[i] > 0)
         {
@@ -445,15 +446,15 @@ fapi2::ReturnCode apply_overlay_ring(
     }
 
     // Processing remainder of data & care bits (mod 8)
-    if (tgtRawSize % 8)
+    if (tgtRawLength % 8)
     {
-        i = tgtRawSize / 8;
+        i = tgtRawLength / 8;
 
-        careOvly[i] &= ~(0xFF << (8 - (tgtRawSize % 8)));
+        careOvly[i] &= ~(0xFF << (8 - (tgtRawLength % 8)));
 
         if (careOvly[i] > 0)
         {
-            for (j = 0; j < tgtRawSize % 8; j++)
+            for (j = 0; j < tgtRawLength % 8; j++)
             {
                 if (careOvly[i] & (0x80 >> j))
                 {
@@ -486,7 +487,7 @@ fapi2::ReturnCode apply_overlay_ring(
                MAX_RING_BUF_SIZE,
                dataTgt,
                careTgt,
-               tgtRawSize,
+               tgtRawLength,
                l_rs4RefHeader.iv_scanAddr,
                l_rs4RefHeader.iv_ringId,
                UNDEFINED_RS4_SELECTOR,
@@ -1103,33 +1104,49 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
     Rs4Selector_t   i_numberOfFeatures,
     void*           i_dynamicRingSection )
 {
-    ReturnCode l_fapiRc = fapi2::FAPI2_RC_SUCCESS;
+    ReturnCode   l_fapiRc = fapi2::FAPI2_RC_SUCCESS;
     fapi2::current_err  = fapi2::FAPI2_RC_SUCCESS;
-    int        l_rc = INFRASTRUCT_RC_SUCCESS;;
-
-    FAPI_DBG("_fetch_and_insert_vpd_ring: (ringId,chipletSel) = (0x%x,0x%08x)",
-             i_ringId, i_chipletSel);
+    int          l_rc = INFRASTRUCT_RC_SUCCESS;;
+    RingId_t     rpIndex = UNDEFINED_RING_ID;
+    RingClass_t  ringClass = UNDEFINED_RING_CLASS;
+    TorHeader_t* torHeader = (TorHeader_t*)i_ringSection;
 
     void*        vpdRing = NULL;
     uint32_t     vpdRingSize = 0;
     void*        finalVpdRing = NULL;
-    MvpdKeyword  l_mvpdKeyword;
-    uint8_t      l_chipletId = (uint8_t)(i_chipletSel >> 24);
+    MvpdKeyword  mvpdKeyword;
+    uint8_t      chipletId = (uint8_t)(i_chipletSel >> 24);
+
+    FAPI_DBG("_fetch_and_insert_vpd_ring: (ringId,chipletSel) = (0x%x,0x%08x)",
+             i_ringId, i_chipletSel);
+
+    // Check the ringId validity, then get the ring properties (rp) index
+    l_rc = ringid_check_ringId( torHeader->chipId, i_ringId);
+
+    FAPI_ASSERT( l_rc == TOR_SUCCESS,
+                 fapi2::XIPC_CODE_BUG().
+                 set_CHIP_TARGET(i_procTarget).
+                 set_OCCURRENCE(3),
+                 "CODE BUG(3): ringid_check_ringId() failed w/rc=0x%08x. Calling code must make"
+                 " sure it passes valid ringId(=0x%x) to _fetch(). Fix calling code.\n",
+                 l_rc, i_ringId);
 
-    RingClass_t l_ringClass = i_ringProps[i_ringId].ringClass;
+    rpIndex = ringid_convert_ringId_to_rpIndex( i_ringId);
 
-    switch (l_ringClass & RCLS_MVPD_MASK)
+    ringClass = i_ringProps[rpIndex].ringClass;
+
+    switch (ringClass & RCLS_MVPD_MASK)
     {
         case RMRK_MVPD_PDG: // #G Time rings
-            l_mvpdKeyword = fapi2::MVPD_KEYWORD_PDG;
+            mvpdKeyword = fapi2::MVPD_KEYWORD_PDG;
             break;
 
         case RMRK_MVPD_PDP: // #P Pll rings
-            l_mvpdKeyword = fapi2::MVPD_KEYWORD_PDP;
+            mvpdKeyword = fapi2::MVPD_KEYWORD_PDP;
             break;
 
         case RMRK_MVPD_PDR: // #R Repair rings
-            l_mvpdKeyword = fapi2::MVPD_KEYWORD_PDR;
+            mvpdKeyword = fapi2::MVPD_KEYWORD_PDR;
             break;
 
         default:
@@ -1137,11 +1154,11 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                          fapi2::XIPC_INVALID_MVPD_RINGCLASS().
                          set_CHIP_TARGET(i_procTarget).
                          set_RING_ID(i_ringId).
-                         set_RING_CLASS(l_ringClass).
+                         set_RING_CLASS(ringClass).
                          set_KWD_MASK(RCLS_MVPD_MASK),
-                         "Code bug: Unsupported value of ringClass (=0x%4x) or keyword"
+                         "CODE BUG: Unsupported value of ringClass (=0x%4x) or keyword"
                          " mask (=0x%4x) for ringId=0x%x",
-                         l_ringClass, RCLS_MVPD_MASK, i_ringId );
+                         ringClass, RCLS_MVPD_MASK, i_ringId );
             break;
     }
 
@@ -1158,7 +1175,7 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
 
     l_fapiRc = getMvpdRing( i_procTarget,
                             MVPD_RECORD_CP00,
-                            l_mvpdKeyword,
+                            mvpdKeyword,
                             i_chipletSel,
                             i_ringId,
                             (uint8_t*)vpdRing,
@@ -1194,7 +1211,7 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                      set_CHIPLET_SEL(i_chipletSel).
                      set_MVPD_CHIPLET_SEL(vpdChipletSel).
                      set_RING_ID(i_ringId),
-                     "_fetch_and_insert_vpd_ring: Code bug: VPD ring's chipletSel"
+                     "CODE BUG: _fetch_and_insert_vpd_ring: VPD ring's chipletSel"
                      " (=0x%08x) doesn't match the requested chipletSel (=0x%08x)",
                      vpdChipletSel, i_chipletSel );
 
@@ -1203,17 +1220,17 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                      fapi2::XIPC_MVPD_RING_SIZE_MESS().
                      set_CHIP_TARGET(i_procTarget).
                      set_RING_ID(i_ringId).
-                     set_CHIPLET_ID(l_chipletId).
+                     set_CHIPLET_ID(chipletId).
                      set_RING_BUFFER_SIZE(i_ringBufSize1).
                      set_MVPD_RING_SIZE(vpdRingSize),
-                     "_fetch_and_insert_vpd_ring: Code bug: VPD ring size (=0x%X) exceeds"
+                     "ERROR: _fetch_and_insert_vpd_ring: MVPD ring size (=0x%X) exceeds"
                      " allowed ring buffer size (=0x%X)",
                      vpdRingSize, i_ringBufSize1 );
 
         // Check for Gptr ring in the .overlays section and if found overlay it onto
         // the Mvpd-Gptr ring.  Further, check for Gptr rings in the .dynamic section
         // and if found overlay them onto the previously overlaid Gptr ring.
-        if ( l_ringClass & RMRK_GPTR_OVLY )
+        if ( ringClass & RMRK_GPTR_OVLY )
         {
             FAPI_TRY( process_gptr_rings(
                           i_procTarget,
@@ -1270,19 +1287,19 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                      set_CHIP_TARGET(i_procTarget).
                      set_LOCAL_RC(l_rc).
                      set_RING_ID(i_ringId).
-                     set_CHIPLET_ID(l_chipletId).
+                     set_CHIPLET_ID(chipletId).
                      set_REDUNDANT(redundant).
                      set_OCCURRENCE(1),
                      "ERROR: rs4_redundant failed w/rc=0x%08x or redundant=%u for"
                      " ringId=0x%x, chipletId=0x%02x, occurrence=1 ",
-                     l_rc, redundant, i_ringId, l_chipletId );
+                     l_rc, redundant, i_ringId, chipletId );
 
         if (redundant)
         {
             io_ringStatusInMvpd = RING_REDUNDANT;
 
             FAPI_DBG("Skipping redundant MVPD ring: ringId=0x%x, chipletId=0x%02x ",
-                     i_ringId, l_chipletId);
+                     i_ringId, chipletId);
             fapi2::current_err = RC_XIPC_RING_IS_REDUNDANT;
             goto fapi_try_exit;
         }
@@ -1312,7 +1329,7 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                          set_SIZE_OF_THIS_RING(vpdRingSize).
                          set_MAX_RING_SECTION_SIZE(i_maxRingSectionSize).
                          set_RING_ID(i_ringId).
-                         set_CHIPLET_ID(l_chipletId).
+                         set_CHIPLET_ID(chipletId).
                          set_CURRENT_BOOT_CORE_MASK(io_bootCoreMask),
                          "Ran out of image buffer space trying to append a ring"
                          " to the .rings section\n"
@@ -1323,7 +1340,7 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                          "maxRingSectionSize: %d\n"
                          "Current bootCoreMask: 0x%08x",
                          i_ringId,
-                         l_chipletId,
+                         chipletId,
                          vpdRingSize,
                          io_ringSectionSize,
                          i_maxRingSectionSize,
@@ -1335,7 +1352,7 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                    i_ringSection,
                    i_maxRingSectionSize,
                    i_ringId,
-                   l_chipletId,
+                   chipletId,
                    finalVpdRing );
 
         FAPI_ASSERT( l_rc == INFRASTRUCT_RC_SUCCESS,
@@ -1347,11 +1364,11 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                      "tor_append_ring() failed in sysPhase=%d w/rc=%d for ringId=0x%x",
                      i_sysPhase, l_rc, i_ringId );
 
-        io_ringSectionSize = be32toh(((TorHeader_t*)i_ringSection)->size);
+        io_ringSectionSize = be32toh(torHeader->size);
 
         FAPI_IMP("Successfully appended Mvpd ring w/(ringId,chipletId)=(0x%x,0x%02x) and now"
                  " ringSectionSize=%u",
-                 i_ringId, l_chipletId, io_ringSectionSize);
+                 i_ringId, chipletId, io_ringSectionSize);
     }
     else if ((uint32_t)l_fapiRc == RC_MVPD_RING_NOT_FOUND)
     {
@@ -1362,7 +1379,7 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
         // rings we're looking for in Mvpd really should be represented there.
         FAPI_DBG("INFO(NOT-A-BUG): _fetch_and_insert_vpd_rings(): The ring w/"
                  "(ringId,chipletId)=(0x%x,0x%02x) was not found.",
-                 i_ringId, l_chipletId);
+                 i_ringId, chipletId);
 
         fapi2::current_err = fapi2::FAPI2_RC_SUCCESS;
     }
@@ -1379,7 +1396,7 @@ fapi2::ReturnCode _fetch_and_insert_vpd_rings(
                      fapi2::XIPC_MVPD_RING_SIZE_TOO_BIG().
                      set_CHIP_TARGET(i_procTarget).
                      set_RING_ID(i_ringId).
-                     set_CHIPLET_ID(l_chipletId).
+                     set_CHIPLET_ID(chipletId).
                      set_RING_BUFFER_SIZE(i_ringBufSize1).
                      set_MVPD_RING_SIZE(vpdRingSize),
                      "_fetch_and_insert_vpd_ring(): VPD ring size (=0x%X) exceeds"
@@ -1443,12 +1460,13 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
     uint32_t        i_ringBufSize2,
     void*           i_ringBuf3,
     uint32_t        i_ringBufSize3,
-    uint32_t&       io_bootCoreMask,
     std::map<Rs4Selector_t, Rs4Selector_t>& i_idxFeatureMap,
     std::map<RingId_t, uint64_t>& io_ringIdFeatureVecMap,
     Rs4Selector_t   i_numberOfFeatures,
     void*           i_dynamicRingSection,
-    uint8_t         i_ddLevel )
+    uint8_t         i_ddLevel,
+    RingProperties_t* i_ringProps,
+    uint32_t&       io_bootCoreMask )
 {
 
     ReturnCode l_fapiRc = fapi2::FAPI2_RC_SUCCESS;
@@ -1498,45 +1516,34 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
     // 1- Add all NEST rings
     // 2- Add QUAD rings in EC order
 
-    RingId_t          l_ringId;
-    RingClass_t       l_ringClass;
-    RingProperties_t* l_ringProps;
+    RingId_t          rpIndex; // Ring properties (rp) index counter
+    RingClass_t       ringClass;
     ChipletData_t*    l_chipletData;
     ChipletData_t*    l_chipletDataEQ, *l_chipletDataEC;
     uint8_t           l_chipletId;  // Nibbles {0,1} of scanScomAddr
     uint32_t          l_regionSel;  // Nibbles {2,4,5,6} of scanScomAddr (region select target)
     uint32_t          l_chipletSel; // Combination of chipletId and regionSel
 
-    l_rc = ringid_get_ringProps( CID_P10, &l_ringProps);
-
-    FAPI_ASSERT( l_rc == INFRASTRUCT_RC_SUCCESS,
-                 fapi2::XIPC_RINGID_RINGPROPS_ERROR().
-                 set_CHIP_TARGET(i_procTarget).
-                 set_LOCAL_RC(l_rc).
-                 set_OCCURRENCE(1),
-                 "ringid_get_ringProps(): Failed w/rc=%i for occurrence=1",
-                 l_rc );
-
 
     // ----------------------------------------------------
     // 1- Add all common rings (ie, non-EQ/core repr rings)
     // ----------------------------------------------------
     l_ringType = COMMON_RING;
 
-    for ( l_ringId = 0; l_ringId < NUM_RING_IDS; l_ringId++ )
+    for ( rpIndex = 0; rpIndex < NUM_RING_IDS; rpIndex++ )
     {
 
-        l_ringClass = l_ringProps[l_ringId].ringClass;
+        ringClass = i_ringProps[rpIndex].ringClass;
 
-        if ( ( l_ringClass != UNDEFINED_RING_CLASS )  &&
-             ( l_ringClass & RCLS_MVPD_MASK )  &&
-             ( (l_ringClass & RCLS_MVPD_PDR_EQ) != RCLS_MVPD_PDR_EQ )  &&
-             ( (l_ringClass & RCLS_MVPD_PDR_CORE) != RCLS_MVPD_PDR_CORE ) )
+        if ( ( ringClass != UNDEFINED_RING_CLASS )  &&
+             ( ringClass & RCLS_MVPD_MASK )  &&
+             ( (ringClass & RCLS_MVPD_PDR_EQ) != RCLS_MVPD_PDR_EQ )  &&
+             ( (ringClass & RCLS_MVPD_PDR_CORE) != RCLS_MVPD_PDR_CORE ) )
         {
             l_rc = ringid_get_chipletProps( CID_P10,
                                             torMagic,
                                             torVersion,
-                                            l_ringProps[l_ringId].chipletType,
+                                            i_ringProps[rpIndex].chipletType,
                                             &l_chipletData );
 
             FAPI_ASSERT( l_rc == INFRASTRUCT_RC_SUCCESS,
@@ -1545,16 +1552,16 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                          set_LOCAL_RC(l_rc).
                          set_TOR_MAGIC(torMagic).
                          set_TOR_VER(torVersion).
-                         set_CHIPLET_TYPE(l_ringProps[l_ringId].chipletType).
-                         set_RING_ID(l_ringId).
+                         set_CHIPLET_TYPE(i_ringProps[rpIndex].chipletType).
+                         set_RING_ID(i_ringProps[rpIndex].ringId).
                          set_OCCURRENCE(1),
                          "ringid_get_chipletProps(): Failed w/rc=%i for"
                          " TOR magic = 0x%04x, TOR version = %d,"
                          " chipletType = %d, ringId = 0x%x,"
                          " occurrence=1",
                          l_rc, torMagic, torVersion,
-                         l_ringProps[l_ringId].chipletType,
-                         l_ringId );
+                         i_ringProps[rpIndex].chipletType,
+                         i_ringProps[rpIndex].ringId );
 
             l_chipletId = l_chipletData->chipletBaseId;
             l_chipletSel = ((uint32_t)l_chipletId) << 24;
@@ -1564,7 +1571,7 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
             // - Fetch QME scannable VPD rings for QME.
 
             if ( i_sysPhase == SYSPHASE_HB_SBE   ||
-                 ( i_sysPhase == SYSPHASE_RT_QME && ( l_ringClass & RMRK_SCAN_BY_QME ) ) )
+                 ( i_sysPhase == SYSPHASE_RT_QME && ( ringClass & RMRK_SCAN_BY_QME ) ) )
             {
                 l_fapiRc = _fetch_and_insert_vpd_rings (
                                i_procTarget,
@@ -1580,8 +1587,8 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                                i_ringBufSize2,
                                i_ringBuf3,
                                i_ringBufSize3,
-                               l_ringProps,
-                               l_ringId,
+                               i_ringProps,
+                               i_ringProps[rpIndex].ringId,
                                l_chipletSel,
                                l_ringStatusInMvpd,
                                l_bImgOutOfSpace,
@@ -1630,7 +1637,7 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
             continue;
         }
 
-        for ( l_ringId = 0; l_ringId < NUM_RING_IDS; l_ringId++ )
+        for ( rpIndex = 0; rpIndex < NUM_RING_IDS; rpIndex++ )
         {
 
             //
@@ -1641,18 +1648,18 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
             // consistent, and in case for some reason suddenly the QME is able to
             // "scan itself", we consider the RT_QME phase here as well.
             //
-            l_ringClass = l_ringProps[l_ringId].ringClass;
+            ringClass = i_ringProps[rpIndex].ringClass;
 
-            if ( ( l_ringClass != UNDEFINED_RING_CLASS )  &&
-                 ( (l_ringClass & RCLS_MVPD_PDR_EQ) == RCLS_MVPD_PDR_EQ )  &&
+            if ( ( ringClass != UNDEFINED_RING_CLASS )  &&
+                 ( (ringClass & RCLS_MVPD_PDR_EQ) == RCLS_MVPD_PDR_EQ )  &&
                  ( i_sysPhase == SYSPHASE_HB_SBE  ||
-                   ( i_sysPhase == SYSPHASE_RT_QME && (l_ringClass & RMRK_SCAN_BY_QME) ) ) )
+                   ( i_sysPhase == SYSPHASE_RT_QME && (ringClass & RMRK_SCAN_BY_QME) ) ) )
             {
                 l_rc = ringid_get_chipletProps(
                            CID_P10,
                            torMagic,
                            torVersion,
-                           l_ringProps[l_ringId].chipletType,
+                           i_ringProps[rpIndex].chipletType,
                            &l_chipletDataEQ );
 
                 FAPI_ASSERT( l_rc == INFRASTRUCT_RC_SUCCESS,
@@ -1661,22 +1668,22 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                              set_LOCAL_RC(l_rc).
                              set_TOR_MAGIC(torMagic).
                              set_TOR_VER(torVersion).
-                             set_CHIPLET_TYPE(l_ringProps[l_ringId].chipletType).
-                             set_RING_ID(l_ringId).
+                             set_CHIPLET_TYPE(i_ringProps[rpIndex].chipletType).
+                             set_RING_ID(i_ringProps[rpIndex].ringId).
                              set_OCCURRENCE(2),
                              "ringid_get_chipletProps(): Failed w/rc=%i for"
                              " TOR magic = 0x%04x, TOR version = %d,"
                              " chipletType = %d, ringId = 0x%x,"
                              " occurrence=2",
                              l_rc, torMagic, torVersion,
-                             l_ringProps[l_ringId].chipletType,
-                             l_ringId );
+                             i_ringProps[rpIndex].chipletType,
+                             i_ringProps[rpIndex].ringId );
 
                 l_chipletId = l_chipletDataEQ->chipletBaseId + eq;
                 l_chipletSel = ((uint32_t)l_chipletId) << 24;
 
                 FAPI_DBG("EQ=%d; chipletId=0x%02x, ringName:%s",
-                         eq, l_chipletId, l_ringProps[l_ringId].ringName);
+                         eq, l_chipletId, i_ringProps[rpIndex].ringName);
 
                 // Update for ring in scan mode
                 l_ringStatusInMvpd = RING_SCAN;
@@ -1695,8 +1702,8 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                                i_ringBufSize2,
                                i_ringBuf3,
                                i_ringBufSize3,
-                               l_ringProps,
-                               l_ringId,
+                               i_ringProps,
+                               i_ringProps[rpIndex].ringId,
                                l_chipletSel,
                                l_ringStatusInMvpd,
                                l_bImgOutOfSpace,
@@ -1734,7 +1741,7 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
 
             } // Done w/fetch_and_insert() current EQ instance ring
 
-        } // End of for(l_ringId) for the current eq
+        } // End of for(rpIndex) for the current eq
 
         //
         // At this point, we're done appending all possible EQ Mvpd rings for current eq.
@@ -1752,25 +1759,25 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                 continue;
             }
 
-            for ( l_ringId = 0; l_ringId < NUM_RING_IDS; l_ringId++ )
+            for ( rpIndex = 0; rpIndex < NUM_RING_IDS; rpIndex++ )
             {
 
                 //
                 // Determine if ringId belongs to relevant Mvpd #R EC ringClass. If so,
                 // then try fetch the ring from Mvpd and append it to ring section.
                 //
-                l_ringClass = l_ringProps[l_ringId].ringClass;
+                ringClass = i_ringProps[rpIndex].ringClass;
 
-                if ( ( l_ringClass != UNDEFINED_RING_CLASS )  &&
-                     ( (l_ringClass & RCLS_MVPD_PDR_CORE) == RCLS_MVPD_PDR_CORE )  &&
+                if ( ( ringClass != UNDEFINED_RING_CLASS )  &&
+                     ( (ringClass & RCLS_MVPD_PDR_CORE) == RCLS_MVPD_PDR_CORE )  &&
                      ( i_sysPhase == SYSPHASE_HB_SBE  ||
-                       ( i_sysPhase == SYSPHASE_RT_QME && (l_ringClass & RMRK_SCAN_BY_QME) ) ) )
+                       ( i_sysPhase == SYSPHASE_RT_QME && (ringClass & RMRK_SCAN_BY_QME) ) ) )
                 {
                     l_rc = ringid_get_chipletProps(
                                CID_P10,
                                torMagic,
                                torVersion,
-                               l_ringProps[l_ringId].chipletType,
+                               i_ringProps[rpIndex].chipletType,
                                &l_chipletDataEC );
 
                     FAPI_ASSERT( l_rc == INFRASTRUCT_RC_SUCCESS,
@@ -1779,16 +1786,16 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                                  set_LOCAL_RC(l_rc).
                                  set_TOR_MAGIC(torMagic).
                                  set_TOR_VER(torVersion).
-                                 set_CHIPLET_TYPE(l_ringProps[l_ringId].chipletType).
-                                 set_RING_ID(l_ringId).
+                                 set_CHIPLET_TYPE(i_ringProps[rpIndex].chipletType).
+                                 set_RING_ID(i_ringProps[rpIndex].ringId).
                                  set_OCCURRENCE(3),
                                  "ringid_get_chipletProps(): Failed w/rc=%i for"
                                  " TOR magic = 0x%04x, TOR version = %d,"
                                  " chipletType = %d, ringId = 0x%x,"
                                  " occurrence=3",
                                  l_rc, torMagic, torVersion,
-                                 l_ringProps[l_ringId].chipletType,
-                                 l_ringId );
+                                 i_ringProps[rpIndex].chipletType,
+                                 i_ringProps[rpIndex].ringId );
 
                     //
                     // Calculate chipletSel target "ID" for this particular (eq,quadrant) combo
@@ -1804,7 +1811,7 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                     // in the scanScomAddr, and see if it matches the current quadrant we're in:
                     // - If there's a match, regionSel will have one bit set,
                     // - If there's no match, regionSel will be zero.
-                    l_regionSel = l_ringProps[l_ringId].scanScomAddr & l_regionSel;
+                    l_regionSel = i_ringProps[rpIndex].scanScomAddr & l_regionSel;
                     // Final chipletSel to look for in Mvpd
                     l_chipletSel = ( (uint32_t)l_chipletId << 24 ) | l_regionSel;
 
@@ -1816,12 +1823,12 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                         // ringIds scanScomAddr.  Proceed to the next ringId.
                         FAPI_DBG("EC=%d: chipletSel=0x%08x, ringName=%s (Skipping this ring"
                                  " because we're in wrong quadrant(=%d))",
-                                 ec, l_chipletSel, l_ringProps[l_ringId].ringName, quadrant);
+                                 ec, l_chipletSel, i_ringProps[rpIndex].ringName, quadrant);
                         continue;
                     }
 
                     FAPI_DBG("EC=%d: chipletSel=0x%08x, ringName=%s",
-                             ec, l_chipletSel, l_ringProps[l_ringId].ringName);
+                             ec, l_chipletSel, i_ringProps[rpIndex].ringName);
 
                     // Update for ring in scan mode
                     l_ringStatusInMvpd = RING_SCAN;
@@ -1840,8 +1847,8 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
                                    i_ringBufSize2,
                                    i_ringBuf3,
                                    i_ringBufSize3,
-                                   l_ringProps,
-                                   l_ringId,
+                                   i_ringProps,
+                                   i_ringProps[rpIndex].ringId,
                                    l_chipletSel,
                                    l_ringStatusInMvpd,
                                    l_bImgOutOfSpace,
@@ -1887,7 +1894,7 @@ fapi2::ReturnCode fetch_and_insert_vpd_rings(
 
                 } // Done inserting current ec core instance ring
 
-            } //for(ringId) - Done inserting all core instance rings for current ec core
+            } //for(rpIndex) - Done inserting all core instance rings for current ec core
 
         } //for (quadrant=0; quadrant<CORES_PER_QME; quadrant++)
 
@@ -1995,7 +2002,7 @@ fapi_try_exit:
                                          fapi2::XIPC_CODE_BUG().
                                          set_CHIP_TARGET(i_procTarget).
                                          set_OCCURRENCE(1),
-                                         "Code bug(1): Incorrect EC mask. Should never get here. Fix code!" );
+                                         "CODE BUG(1): Incorrect EC mask. Should never get here. Fix code!" );
                             break;
                     }
                 }
@@ -2397,10 +2404,13 @@ ReturnCode p10_ipl_customize (
     uint32_t        sizeMvpdCIField = 0;
     uint8_t*        fullCIData = nullptr;
 
+    RingProperties_t* ringProps = nullptr; // Ring properties list
+    RingId_t        ringId = UNDEFINED_RING_ID;
+    RingId_t        rpIndex = UNDEFINED_RING_ID; // Ring properties (rp) index
+
     uint64_t        featureVec = 0; // Dynamic inits feature vector from platform attribute
     fapi2::ATTR_SYSTEM_IPL_PHASE_Type l_attrSystemIplPhase;
     fapi2::ATTR_CONTAINED_IPL_TYPE_Type l_attrContainedIplType;
-    RingId_t        ringId = UNDEFINED_RING_ID;
     std::map< Rs4Selector_t,  Rs4Selector_t> idxFeatureMap;
     std::map<RingId_t, uint64_t> ringIdFeatureVecMap;
     uint8_t*        ringIdFeatList = NULL;
@@ -2468,7 +2478,7 @@ ReturnCode p10_ipl_customize (
                      set_CHIP_TARGET(i_procTarget).
                      set_XIP_RC(l_rc).
                      set_OCCURRENCE(1),
-                     "p9_xip_image_size() failed w/rc=0x%08x at occurrence=1",
+                     "p9_xip_image_size() failed (1) w/rc=0x%08x",
                      (uint32_t)l_rc );
 
         FAPI_DBG("Input image size: %d", l_inputImageSize);
@@ -3184,6 +3194,17 @@ ReturnCode p10_ipl_customize (
                  set_CHIP_TARGET(i_procTarget),
                  "tor_skeleton_generation failed w/rc=0x%08X", (uint32_t)l_rc );
 
+    // We will be needing the ring properties (rp) list for both Dynamic and Mvpd rings
+    l_rc = ringid_get_ringProps( CID_P10, &ringProps);
+
+    FAPI_ASSERT( l_rc == INFRASTRUCT_RC_SUCCESS,
+                 fapi2::XIPC_RINGID_RINGPROPS_ERROR().
+                 set_CHIP_TARGET(i_procTarget).
+                 set_LOCAL_RC(l_rc).
+                 set_OCCURRENCE(1),
+                 "ringid_get_ringProps(): Failed w/rc=%i for occurrence=1",
+                 l_rc );
+
     // Now, start tracking the instantaneous actual custom ring section size.
     // (Note that we already took a copy of the [max] value of io_ringSectionBufSize
     // earlier on into l_ringSectionBufSize, so safe to update this now.)
@@ -3261,10 +3282,6 @@ ReturnCode p10_ipl_customize (
     //            ring becomes the de facto Base ring.
     //////////////////////////////////////////////////////////////////////////
 
-    // TODO / FIXME: The mapping from bit position in the vector to features
-    //               should be encapsulated in an enum constructed at ekb build
-    //               time.
-
     //
     // Get the feature vector from the platform
     //
@@ -3405,10 +3422,14 @@ ReturnCode p10_ipl_customize (
 
     dynamicRingSection = (void*)((uint8_t*)i_hwImage + iplImgSection.iv_offset);
 
-    for(ringId = 0; ringId < NUM_RING_IDS; ringId++)
+    for (rpIndex = 0; rpIndex < NUM_RING_IDS; rpIndex++)
     {
-        // Only process non-Mvpd rings (and which are all assumed to be Common rings)
-        if ( ringid_is_mvpd_ring(torHeaderBase->chipId, ringId) == true )
+        // Get the ringId from the RP list
+        ringId = ringProps[rpIndex].ringId;
+
+        // Only process non-Mvpd (which are all Common rings)
+        if ( ringid_is_mvpd_ring(torHeaderBase->chipId, ringId) == true ||
+             ringId == HOLE_RING_ID )
         {
             continue;
         }
@@ -3416,7 +3437,7 @@ ReturnCode p10_ipl_customize (
         l_fapiRc = process_target_and_dynamic_rings(
                        i_procTarget,
                        true,//true means next arg is Base ringSection ptr
-                       baseRingSection,//Overloaded (false:RS4 ring in mid-Buf1,true:Base ringSection)
+                       baseRingSection,//Overloaded (false:RS4 ring in mid-Buf1,true:Base section)
                        dynamicRingSection,
                        i_ringBuf1,//On return, contains Base ring overlaid with dynamic rings
                        i_ringBuf2,
@@ -3484,15 +3505,15 @@ ReturnCode p10_ipl_customize (
                                  fapi2::XIPC_CODE_BUG().
                                  set_CHIP_TARGET(i_procTarget).
                                  set_OCCURRENCE(2),
-                                 "Code bug(2): Messed up RC handling in assoc code. Fix code!" );
+                                 "CODE BUG(2): Messed up RC handling in assoc code. Fix code!" );
                     break;
             }
-
         }
     }
 
 
 
+
     //////////////////////////////////////////////////////////////////////////
     // CUSTOMIZE item:     Append VPD rings to io_ringSectionBuf
     // System phase:       All phases
@@ -3594,12 +3615,13 @@ ReturnCode p10_ipl_customize (
                                                    i_ringBufSize2,
                                                    i_ringBuf3,
                                                    i_ringBufSize3,
-                                                   io_bootCoreMask,
                                                    idxFeatureMap,
                                                    ringIdFeatureVecMap,
                                                    numberOfFeatures,
                                                    dynamicRingSection,
-                                                   attrDdLevel );
+                                                   attrDdLevel,
+                                                   ringProps,
+                                                   io_bootCoreMask );
 
             FAPI_DBG("-----------------------------------------------------------------------");
             FAPI_DBG("bootCoreMask:  Requested=0x%08X  Final=0x%08X",
@@ -3611,8 +3633,8 @@ ReturnCode p10_ipl_customize (
 
                 if ((uint32_t)l_fapiRc == RC_XIPC_IMAGE_WOULD_OVERFLOW)
                 {
-                    FAPI_DBG("p10_ipl_customize(): SBE image is full. Ran out of space appending VPD rings"
-                             " to the .rings section");
+                    FAPI_DBG("p10_ipl_customize(): SBE image is full. Ran out of space appending"
+                             " VPD rings to the .rings section");
 
                     // Check the bootCoreMask to determine if enough cores have been configured.
                     uint8_t attrMinReqdEcs = 0;
@@ -3670,7 +3692,8 @@ ReturnCode p10_ipl_customize (
                          set_RING_SECTION_BUF_SIZE(l_ringSectionBufSize).
                          set_MAX_RING_SECTION_SIZE(l_maxRingSectionSize).
                          set_OCCURRENCE(2),
-                         "Code bug: ringSectionBufSize(=%d) > maxRingSectionSize(=%d) in HB_SBE (Occurrence 2)",
+                         "CODE BUG: ringSectionBufSize(=%d) > maxRingSectionSize(=%d) in HB_SBE"
+                         " (Occurrence 2)",
                          io_ringSectionBufSize, l_maxRingSectionSize );
 
             FAPI_ASSERT( (l_imageSizeWithoutRings + io_ringSectionBufSize) <= l_maxImageSize,
@@ -3679,7 +3702,7 @@ ReturnCode p10_ipl_customize (
                          set_IMAGE_SIZE_WITHOUT_RINGS(l_imageSizeWithoutRings).
                          set_RING_SECTION_SIZE(io_ringSectionBufSize).
                          set_MAX_IMAGE_SIZE(l_maxImageSize),
-                         "Code bug: SBE imageSize would exceed maxImageSize" );
+                         "CODE BUG: SBE imageSize would exceed maxImageSize" );
 
             FAPI_DBG( "SBE image details: io_ringSectionBufSize=%d, l_imageSizeWithoutRings=%d,"
                       "  l_maxImageSize=%d",
@@ -3751,12 +3774,13 @@ ReturnCode p10_ipl_customize (
                                                    i_ringBufSize2,
                                                    i_ringBuf3,
                                                    i_ringBufSize3,
-                                                   io_bootCoreMask,
                                                    idxFeatureMap,
                                                    ringIdFeatureVecMap,
                                                    numberOfFeatures,
                                                    dynamicRingSection,
-                                                   attrDdLevel );
+                                                   attrDdLevel,
+                                                   ringProps,
+                                                   io_bootCoreMask );
 
             FAPI_DBG("Size of QME .rings section after VPD update: %d", io_ringSectionBufSize );
 
@@ -3788,7 +3812,7 @@ ReturnCode p10_ipl_customize (
                          set_RING_SECTION_BUF_SIZE(l_ringSectionBufSize).
                          set_MAX_RING_SECTION_SIZE(l_maxRingSectionSize).
                          set_OCCURRENCE(3),
-                         "Code bug: QME ring section size(=%d) > maxRingSectionSize(=%d)"
+                         "CODE BUG: QME ring section size(=%d) > maxRingSectionSize(=%d)"
                          " in RT_QME (Occurrence 3)",
                          io_ringSectionBufSize, l_maxRingSectionSize );
 
diff --git a/src/import/chips/p10/procedures/hwp/customize/p10_qme_customize.C b/src/import/chips/p10/procedures/hwp/customize/p10_qme_customize.C
index fc645d6..c87fabb 100644
--- a/src/import/chips/p10/procedures/hwp/customize/p10_qme_customize.C
+++ b/src/import/chips/p10/procedures/hwp/customize/p10_qme_customize.C
@@ -43,60 +43,52 @@ using namespace fapi2;
 
 fapi2::ReturnCode p10_qme_customize(
     const fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP>& i_procTarget,
-    uint8_t* i_bufQmeRings,
-    CUSTOM_RING_OP i_custOp,
-    uint8_t* io_bufCustRings,
-    uint32_t& io_bufCustRingsSize,
-    uint32_t i_dbgl)
+    uint8_t*      i_qmeRings,          //Input QME ring section
+    CUST_RING_OP  i_custOp,
+    uint8_t*      io_bufCustRings,     //Buffer for customized output QME ring section
+    uint32_t&     io_bufCustRingsSize, //In: Max buf size, Out: cust ring section size
+    uint32_t      i_dbgl )
 {
-    int rc = INFRASTRUCT_RC_SUCCESS;
+    int rc = TOR_SUCCESS;
 
-    TorHeader_t* torHeaderQme  = (TorHeader_t*) i_bufQmeRings;
+    TorHeader_t* torHeaderQme  = (TorHeader_t*) i_qmeRings;
     TorHeader_t* torHeaderCust = (TorHeader_t*) io_bufCustRings;
 
-    uint8_t ddLevel;
-    uint8_t torVersion;
-    uint32_t torMagic;
-    uint32_t inputQmeRingsSize;
+    uint32_t inputQmeRingsSize = be32toh(torHeaderQme->size);
+    uint32_t maxCustRingsSize = io_bufCustRingsSize;
 
-    ChipId_t chipId = UNDEFINED_CHIP_ID;
+    RingProperties_t* ringProps = nullptr;
     ChipletData_t* chipletData;
+    RingId_t numRingIds = UNDEFINED_RING_ID;
+    RingId_t rpIndex;
+    uint8_t  chipletId;
+    void*    nextRing = NULL;
+    uint32_t remBufSize;
 
     FAPI_IMP(">> p10_qme_customize ");
 
-    ddLevel = torHeaderQme->ddLevel;
-    torVersion = torHeaderQme->version;
-    torMagic = be32toh(torHeaderQme->magic);
-    chipId = torHeaderQme->chipId;
-    inputQmeRingsSize = be32toh(torHeaderQme->size);
-
-    RingId_t numRings = UNDEFINED_RING_ID; // Number of chiplet common or instance rings
-    MyBool_t bInstCase = UNDEFINED_BOOLEAN; // 0:COMMON, 1:INSTANCE rings
-    RingId_t ringId;
-    uint8_t  chipletInstId;
-
-    uint32_t maxCustRingsSize = io_bufCustRingsSize;
-
-    uint8_t  iRing;
-    void*    nextRing = NULL;
-    uint32_t remBufSize;
+    // Take note of some key TOR header input data
+    uint32_t torMagic = be32toh(torHeaderQme->magic);
+    uint8_t  torVersion = torHeaderQme->version;
+    uint8_t  ddLevel = torHeaderQme->ddLevel;
+    ChipId_t chipId = torHeaderQme->chipId;
 
     //
     // Step 0: Test input parameters
     //
-    FAPI_ASSERT(i_custOp < NUM_CUSTOMIZE_QME_ENTRIES
-                && i_bufQmeRings != NULL
+    FAPI_ASSERT(i_custOp < NUM_QME_CUST_OPS
+                && i_qmeRings != NULL
                 && io_bufCustRings != NULL,
                 fapi2::QMEC_FUNC_CALL_ARGUMENT_ERROR()
                 .set_TARGET(i_procTarget)
-                .set_CUSTOM_RING_OP(i_custOp)
-                .set_INPUT_QME_RINGS_BUF_PTR(i_bufQmeRings)
+                .set_CUST_RING_OP(i_custOp)
+                .set_INPUT_QME_RINGS_PTR(i_qmeRings)
                 .set_CUST_QME_RINGS_BUF_PTR(io_bufCustRings),
-                "Error: Some arguments in function call are invalid,\n"
-                " i_custOp=0x%08x, i_bufQmeRings=0x%016llx, io_bufCustRings=0x%016llx.\n",
+                "ERROR: Some arguments in function call are invalid:"
+                " i_custOp=0x%x, i_qmeRings=0x%016llx, io_bufCustRings=0x%016llx.\n",
                 i_custOp,
-                (uintptr_t) i_bufQmeRings,
-                (uintptr_t) io_bufCustRings);
+                (uintptr_t)i_qmeRings,
+                (uintptr_t)io_bufCustRings);
 
     FAPI_ASSERT(torMagic == TOR_MAGIC_QME && torVersion == TOR_VERSION,
                 fapi2::QMEC_TOR_HEADER_MISMATCH()
@@ -105,28 +97,26 @@ fapi2::ReturnCode p10_qme_customize(
                 .set_TOR_MAGIC_QME_DEFINED(TOR_MAGIC_QME)
                 .set_TOR_VERSION_IN_HEADER(torVersion)
                 .set_TOR_VERSION_DEFINED(TOR_VERSION),
-                "Error: TOR Magic or TOR Version not match in TOR header and the defined,\n"
-                " TOR Magic w/value =0x%08x in TOR header, TOR_MAGIC_QME w/value =0x%08x,\n"
-                " TOR Version w/value =0x%08x in TOR header, TOR_VERSION w/value =0x%08x.\n",
+                "ERROR: TOR Magic or TOR Version in TOR header do not match the defined values:\n"
+                " torMagic=0x%08x but TOR_MAGIC_QME=0x%08x\n"
+                " torVersion=%u but TOR_VERSION=%u",
                 torMagic,
                 TOR_MAGIC_QME,
                 torVersion,
                 TOR_VERSION);
 
-    // Make sure that the customized buffer size is greater than or
-    // equal to the size in TOR header in the input QME ring buffer.
+    // Check that the max customized buffer size is >= the size of the input TOR ring section
     FAPI_ASSERT(maxCustRingsSize >= inputQmeRingsSize,
                 fapi2::QMEC_RINGS_OUTPUT_BUFFER_TOO_SMALL()
                 .set_TARGET(i_procTarget)
-                .set_MAX_CUST_RINGS_BUF_SIZE(maxCustRingsSize)
-                .set_INPUT_QME_RINGS_BUF_SIZE(inputQmeRingsSize),
-                "Error: Input QME rings buffer size exceeds max customize ring buffer size,\n"
-                " maxCustRingsSize=0x%08x, inputQmeRingsSize=0x%08x.\n",
+                .set_CUST_QME_RINGS_BUF_SIZE(maxCustRingsSize)
+                .set_INPUT_QME_RINGS_SIZE(inputQmeRingsSize)
+                .set_CUST_QME_RINGS_SIZE(0xffffffff), //Still undefined
+                "ERROR: Max custom QME ring buf size < Input QME rings size:"
+                " maxCustRingsSize=0x%08x, inputQmeRingsSize=0x%08x",
                 maxCustRingsSize,
                 inputQmeRingsSize);
 
-    bInstCase = (i_custOp == CUSTOMIZE_QME_COMMON_RING) ? false : true;
-
     //
     // Step 1: Create TOR skeleton ringSection
     // Create the complete ring skeleton, but with empty TOR ring slots (ie, no ring content).
@@ -139,12 +129,7 @@ fapi2::ReturnCode p10_qme_customize(
                                  chipId,
                                  i_dbgl);
 
-    FAPI_DBG("tor_skeleton_generation() completed w/rc=0x%08x,\n"
-             " torMagic=0x%08x, torVersion=%u,\n"
-             " ddLevel=0x%02x and chipId=0x%02x.\n",
-             rc, torMagic, torVersion, ddLevel, chipId);
-
-    FAPI_ASSERT(rc == INFRASTRUCT_RC_SUCCESS,
+    FAPI_ASSERT(rc == TOR_SUCCESS,
                 fapi2::QMEC_TOR_SKELETON_GEN_ERROR()
                 .set_TARGET(i_procTarget)
                 .set_API_RC(rc)
@@ -152,130 +137,156 @@ fapi2::ReturnCode p10_qme_customize(
                 .set_TOR_VER(torVersion)
                 .set_DD_LEVEL(ddLevel)
                 .set_CHIP_ID(chipId),
-                "Error: tor_skeleton_generation() failed w/rc=0x%08x,"
-                " torMagic=0x%08x, torVersion=%u, ddLevel=0x%02x and chipId=0x%02x\n",
+                "ERROR: tor_skeleton_generation() failed w/rc=0x%08x for"
+                " torMagic=0x%08x, torVersion=%u, ddLevel=0x%02x and chipId=0x%02x",
                 rc, torMagic, torVersion, ddLevel, chipId);
 
-    //
-    // Step 2: Add ring content
-    // Append rings to the end of the [skeleton] TOR ring section and update TOR offset slot
-    //
+    // Get the main ring properties list and the number of RingIDs
+    // (Note that we can skip the second rc check since the API only fails if wrong chipId which
+    // will be caught by the first rc check)
+    rc = ringid_get_ringProps(chipId,
+                              &ringProps);
 
-    // Get all the meta data for this chiplet and its rings
+    FAPI_ASSERT(rc == TOR_SUCCESS,
+                fapi2::QMEC_RINGID_API_ERROR()
+                .set_TARGET(i_procTarget)
+                .set_API_RC(rc)
+                .set_TOR_MAGIC(torMagic)
+                .set_TOR_VER(torVersion)
+                .set_RP_INDEX(UNDEFINED_RING_ID)
+                .set_RING_ID(UNDEFINED_RING_ID)
+                .set_CHIP_ID(chipId)
+                .set_OCCURRENCE(1),
+                "ERROR: ringid_get_ringProps() failed w/rc=0x%08x\n for",
+                " torMagic=0x%08x, torVersion=%u and chipId=0x%02x",
+                rc, torMagic, torVersion, chipId);
+
+    ringid_get_num_ring_ids( chipId,
+                             &numRingIds );
+
+    // Get the meta data for the QME chiplet
     rc = ringid_get_chipletProps(chipId,
                                  torMagic,
                                  torVersion,
                                  EQ_TYPE,
                                  &chipletData);
 
-    FAPI_ASSERT(rc == INFRASTRUCT_RC_SUCCESS,
-                fapi2::QMEC_RINGID_GET_CHIPLETPROPS_ERROR()
+    FAPI_ASSERT(rc == TOR_SUCCESS,
+                fapi2::QMEC_RINGID_API_ERROR()
                 .set_TARGET(i_procTarget)
                 .set_API_RC(rc)
                 .set_TOR_MAGIC(torMagic)
-                .set_TOR_VER(torVersion),
-                "Error: ringid_get_chipletProps() failed w/rc=0x%08x,\n"
-                " torMagic=0x%08x and torVersion=%u.\n",
-                rc, torMagic, torVersion);
+                .set_TOR_VER(torVersion)
+                .set_RP_INDEX(UNDEFINED_RING_ID)
+                .set_RING_ID(UNDEFINED_RING_ID)
+                .set_CHIP_ID(chipId)
+                .set_OCCURRENCE(2),
+                "ERROR: ringid_get_chipletProps() failed w/rc=0x%08x for chipletType=EQ_TYPE,"
+                " torMagic=0x%08x, torVersion=%u and chipId=0x%02x",
+                rc, torMagic, torVersion, chipId);
 
-    chipletInstId = chipletData->chipletBaseId + i_custOp;
+    chipletId = chipletData->chipletBaseId + i_custOp;
 
-    numRings = bInstCase ?
-               chipletData->numInstanceRings :
-               chipletData->numCommonRings;
+    //
+    // Step 2: Copy and append rings
+    //
 
-    // Loop through all rings, get ring data for each ring and
-    // append it to cust ring section.
-    for (iRing = 0; iRing < numRings; iRing++)
+    for (rpIndex = 0; rpIndex < numRingIds; rpIndex++)
     {
-        // Extract ringId from the TOR ring index, iRing.
-        rc = ringidGetRingId2(chipId,
-                              torMagic,
-                              EQ_TYPE,
-                              iRing,
-                              bInstCase,
-                              ringId,
-                              false);
-
-        FAPI_ASSERT(rc == INFRASTRUCT_RC_SUCCESS,
-                    fapi2::QMEC_RINGID_GET_RINGID2_ERROR()
-                    .set_TARGET(i_procTarget)
-                    .set_API_RC(rc)
-                    .set_TOR_MAGIC(torMagic)
-                    .set_RING_INST_ID(iRing)
-                    .set_INST_CASE(bInstCase)
-                    .set_RING_ID(ringId),
-                    "Error: ringidGetRingId2() failed w/rc=0x%08x,\n"
-                    " torMagic=0x%08x, iRing=%u,\n"
-                    " bInstCase=%u and ringId=0x%x.\n",
-                    rc, torMagic, iRing, bInstCase, ringId);
-
         io_bufCustRingsSize = be32toh(torHeaderCust->size);
         nextRing = (void*) (io_bufCustRings + io_bufCustRingsSize);
 
         // nextRing is portion of io_bufCustRings buffer which is used as
-        // temporary buffer to pass the ring in i_bufQmeRings from the
+        // temporary buffer to pass the ring in i_qmeRings from the
         // tor_get_single_ring() function.
         // The size of this temporary buffer is captured by remBufSize.
-        FAPI_ASSERT(maxCustRingsSize > io_bufCustRingsSize,
+        FAPI_ASSERT(maxCustRingsSize >= io_bufCustRingsSize,
                     fapi2::QMEC_RINGS_OUTPUT_BUFFER_TOO_SMALL()
-                    .set_MAX_CUST_RINGS_BUF_SIZE(maxCustRingsSize)
-                    .set_CUST_QME_RINGS_BUF_SIZE(io_bufCustRingsSize),
-                    "Error: QME rings output buffer is not large enough to use part of it for rs4Ring,\n"
-                    " maxCustRingsSize=0x%08x, io_bufCustRingsSize=0x%08x.\n",
+                    .set_TARGET(i_procTarget)
+                    .set_CUST_QME_RINGS_BUF_SIZE(maxCustRingsSize)
+                    .set_INPUT_QME_RINGS_SIZE(inputQmeRingsSize)
+                    .set_CUST_QME_RINGS_SIZE(io_bufCustRingsSize),
+                    "ERROR: QME customize rings output buffer is too small since"
+                    " maxCustRingsSize=0x%08x < io_bufCustRingsSize=0x%08x.",
                     maxCustRingsSize, io_bufCustRingsSize);
 
         remBufSize = maxCustRingsSize - io_bufCustRingsSize;
 
-        // Extract ring data using the ringId.
-        rc = tor_get_single_ring(i_bufQmeRings,
-                                 ddLevel,
-                                 ringId,
-                                 chipletInstId, //This argument ignored for Common rings.
-                                 nextRing,
-                                 remBufSize,
-                                 i_dbgl);
+        //
+        // Extract ring
+        // But skip it if it doesn't qualify for current custOp context
+        //
 
-        FAPI_ASSERT(rc == INFRASTRUCT_RC_SUCCESS ||
-                    rc == TOR_RING_IS_EMPTY,
-                    fapi2::QMEC_TOR_GET_SINGLE_RING_ERROR()
-                    .set_TARGET(i_procTarget)
-                    .set_API_RC(rc)
-                    .set_DD_LEVEL(ddLevel)
-                    .set_RING_ID(ringId)
-                    .set_CHIPLET_INST_ID(chipletInstId)
-                    .set_NEXT_RS4RING_BUF_SIZE(remBufSize),
-                    "Error: tor_get_single_ring() failed w/rc=0x%08x, ddLevel=0x%02x,"
-                    " ringId=0x%x, chipletInstId=0x%02x, remBufSize=%u.\n",
-                    rc, ddLevel, ringId, chipletInstId, remBufSize);
-
-        // If ring is empty, skip and check next ring.
-        if(rc == TOR_RING_IS_EMPTY)
+        RingId_t  ringId = ringProps[rpIndex].ringId;
+        MyBool_t  bInstRing = ringid_is_instance_ring(rpIndex);
+
+        if ( ( bInstRing == true &&
+               (i_custOp >= CUST_QME0_INSTANCE_RING && i_custOp <= CUST_QME7_INSTANCE_RING) ) ||
+             ( bInstRing == false &&
+               (i_custOp == CUST_QME_COMMON_RING) ) )
+        {
+            rc = tor_get_single_ring(i_qmeRings,
+                                     ddLevel,
+                                     ringId,
+                                     chipletId, //Arg ignored for Common rings
+                                     nextRing,
+                                     remBufSize,
+                                     i_dbgl);
+
+
+            FAPI_ASSERT(rc == TOR_SUCCESS ||
+                        rc == TOR_RING_IS_EMPTY ||
+                        rc == TOR_INVALID_CHIPLET_TYPE ||
+                        rc == TOR_HOLE_RING_ID,
+                        fapi2::QMEC_TOR_GET_SINGLE_RING_ERROR()
+                        .set_TARGET(i_procTarget)
+                        .set_API_RC(rc)
+                        .set_DD_LEVEL(ddLevel)
+                        .set_RING_ID(ringId)
+                        .set_CHIPLET_ID(chipletId)
+                        .set_REM_BUF_SIZE(remBufSize),
+                        "ERROR: tor_get_single_ring() failed w/rc=0x%08x, ddLevel=0x%02x,"
+                        " ringId=0x%x, chipletId=0x%02x, remBufSize=0x%08x\n",
+                        rc, ddLevel, ringId, chipletId, remBufSize);
+
+            // If ring is empty, is a hole ring or doesnt belong to QME chiplet => go to next ring
+            if( rc == TOR_RING_IS_EMPTY ||
+                rc == TOR_INVALID_CHIPLET_TYPE ||
+                rc == TOR_HOLE_RING_ID )
+            {
+                //FAPI_DBG("Skipping ringId=0x%03x for rc=0x%08x", ringId, rc);
+                rc = TOR_SUCCESS;
+                continue;
+            }
+        }
+        else
         {
-            rc = INFRASTRUCT_RC_SUCCESS;
             continue;
         }
 
-        // Append ring to ring section.
+        //
+        // Append ring to customized QME ring section.
         // Note that this API also updates the header's ring size
+        //
         rc = tor_append_ring(io_bufCustRings,
                              maxCustRingsSize,
                              ringId,
-                             chipletInstId,
+                             chipletId, //Arg ignored for Common rings
                              (void*)nextRing,
                              i_dbgl);
 
-        io_bufCustRingsSize = be32toh(torHeaderCust->size);
-
-        FAPI_ASSERT(rc == INFRASTRUCT_RC_SUCCESS,
+        FAPI_ASSERT(rc == TOR_SUCCESS,
                     fapi2::QMEC_TOR_APPEND_RING_ERROR()
                     .set_TARGET(i_procTarget)
                     .set_API_RC(rc)
-                    .set_CUST_RINGS_BUF_SIZE(io_bufCustRingsSize)
-                    .set_RING_ID(ringId),
-                    "Error: tor_append_ring() failed w/rc=0x%08x,\n"
-                    " io_bufCustRingsSize=0x%08x, ringId=0x%x.\n",
-                    rc, io_bufCustRingsSize, ringId);
+                    .set_RING_ID(ringId)
+                    .set_CHIPLET_ID(chipletId)
+                    .set_CUST_QME_RINGS_BUF_SIZE(maxCustRingsSize),
+                    "ERROR: tor_append_ring() failed w/rc=0x%08x for ringId=0x%x,"
+                    " chipletId=0x%02x and maxCustRingsSize=0x%08x",
+                    rc, ringId, chipletId, maxCustRingsSize);
+
+        io_bufCustRingsSize = be32toh(torHeaderCust->size);
 
     }
 
diff --git a/src/import/chips/p10/procedures/hwp/customize/p10_qme_customize.H b/src/import/chips/p10/procedures/hwp/customize/p10_qme_customize.H
index b98c891..3d2b527 100644
--- a/src/import/chips/p10/procedures/hwp/customize/p10_qme_customize.H
+++ b/src/import/chips/p10/procedures/hwp/customize/p10_qme_customize.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2016,2019                        */
+/* Contributors Listed Below - COPYRIGHT 2016,2020                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -40,55 +40,50 @@
 /**
  * @brief   various ring customization operation supported by HWP
  */
-enum CUSTOM_RING_OP
+enum CUST_RING_OP
 {
-    CUSTOMIZE_QME0_SPECIFIC_RING = 0x00,
-    CUSTOMIZE_QME1_SPECIFIC_RING = 0x01,
-    CUSTOMIZE_QME2_SPECIFIC_RING = 0x02,
-    CUSTOMIZE_QME3_SPECIFIC_RING = 0x03,
-    CUSTOMIZE_QME4_SPECIFIC_RING = 0x04,
-    CUSTOMIZE_QME5_SPECIFIC_RING = 0x05,
-    CUSTOMIZE_QME6_SPECIFIC_RING = 0x06,
-    CUSTOMIZE_QME7_SPECIFIC_RING = 0x07,
-    CUSTOMIZE_QME_COMMON_RING = 0x08,
-    NUM_CUSTOMIZE_QME_ENTRIES
+    CUST_QME0_INSTANCE_RING = 0x00,
+    CUST_QME1_INSTANCE_RING = 0x01,
+    CUST_QME2_INSTANCE_RING = 0x02,
+    CUST_QME3_INSTANCE_RING = 0x03,
+    CUST_QME4_INSTANCE_RING = 0x04,
+    CUST_QME5_INSTANCE_RING = 0x05,
+    CUST_QME6_INSTANCE_RING = 0x06,
+    CUST_QME7_INSTANCE_RING = 0x07,
+    CUST_QME_COMMON_RING = 0x08,
+    NUM_QME_CUST_OPS
 };
 
 typedef fapi2::ReturnCode (*p10_qme_customize_FP_t)(
     const fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP>& i_procTarget,
-    uint8_t* i_bufQmeRings,
-    CUSTOM_RING_OP i_custOp,
-    uint8_t* io_bufCustRings,
-    uint32_t& io_bufCustRingsSize,
-    uint32_t i_dbgl);
+    uint8_t*      i_qmeRings,
+    CUST_RING_OP  i_custOp,
+    uint8_t*      io_bufCustRings,
+    uint32_t&     io_bufCustRingsSize,
+    uint32_t      i_dbgl);
 
 extern "C"
 {
 
 /// @brief          customizes QME ring section based on input.
 /// @param[in]      i_procTarget reference to processor chip target.
-/// @param[in/out]  i_bufQmeRings pointer to a buffer containing all
-///                     scan rings associated with QME image.
-/// @param[in]      i_custOp type of customization requested.
-/// @param[in/out]  io_bufCustRings pointer to a buffer containing
-///                     customized QME rings.
-/// @param[in/out]  io_bufCustRingsSize reference.
-///                     Input - max buffer size, must be greater than or
-///                         equal to the size in the TOR header of QME
-///                         ring section in the i_bufQmeRing buffer.
-///                     output- the actual buffer size of customized QME
-///                         rings.
-/// @param[in]      i_dbgl  debug level, default value is 0.
-/// @return         FAPI_RC_SUCCESS if the customization was successful,
-///                     error code otherwise.
+/// @param[in/out]  i_qmeRings  Pointer to the input QME ring section
+/// @param[in]      i_custOp  Type of customization requested.
+/// @param[in/out]  io_bufCustRings  Pointer to a buffer containing the customized QME rings.
+/// @param[in/out]  io_bufCustRingsSize  Size of customized QME ring section
+///                     Input - max buffer size, must be >= to the size in the TOR header of
+///                             the input QME ring section in i_qmeRings
+///                     Output- the actual size of the customized QME ring section
+/// @param[in]      i_dbgl  Debug level, default value is 0
+/// @return         FAPI_RC_SUCCESS if the customization was successful, otherwise error code
 
     fapi2::ReturnCode p10_qme_customize(
         const fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP>& i_procTarget,
-        uint8_t* i_bufQmeRings,
-        CUSTOM_RING_OP i_custOp,
-        uint8_t* io_bufCustRings,
-        uint32_t& io_bufCustRingsSize,
-        uint32_t i_dbgl = 0);
+        uint8_t*      i_bufQmeRings,
+        CUST_RING_OP  i_custOp,
+        uint8_t*      io_bufCustRings,
+        uint32_t&     io_bufCustRingsSize,
+        uint32_t      i_dbgl = 0);
 
 } //extern "C"
 
diff --git a/src/import/chips/p10/procedures/hwp/pm/p10_hcode_image_build.C b/src/import/chips/p10/procedures/hwp/pm/p10_hcode_image_build.C
index 0d3441a..d2553cb 100644
--- a/src/import/chips/p10/procedures/hwp/pm/p10_hcode_image_build.C
+++ b/src/import/chips/p10/procedures/hwp/pm/p10_hcode_image_build.C
@@ -1037,7 +1037,7 @@ fapi2::ReturnCode buildQmeSpecificRing( CONST_FAPI2_PROC& i_procTgt, Homerlayout
 
         FAPI_TRY( p10_qme_customize( i_procTgt,
                                      (uint8_t *)i_ringData.iv_pRingBuffer,
-                                     ( CUSTOM_RING_OP )l_superChiplet,
+                                     ( CUST_RING_OP )l_superChiplet,
                                      (uint8_t *)i_ringData.iv_pWorkBuf1,
                                      l_workBufSize,
                                      0 ),
@@ -1071,7 +1071,7 @@ fapi2::ReturnCode buildQmeSpecificRing( CONST_FAPI2_PROC& i_procTgt, Homerlayout
 
         FAPI_TRY( p10_qme_customize( i_procTgt,
                                      (uint8_t *)i_ringData.iv_pRingBuffer,
-                                     ( CUSTOM_RING_OP ) l_superChiplet,
+                                     ( CUST_RING_OP ) l_superChiplet,
                                      (uint8_t *)i_ringData.iv_pWorkBuf1,
                                      l_workBufSize,
                                      0 ),
@@ -1236,7 +1236,7 @@ fapi2::ReturnCode buildQmeRing( CONST_FAPI2_PROC& i_procTgt, void * const i_pIma
 
     FAPI_TRY( p10_qme_customize( i_procTgt,
                                  (uint8_t *)i_ringData.iv_pRingBuffer,
-                                 CUSTOMIZE_QME_COMMON_RING,
+                                 CUST_QME_COMMON_RING,
                                  (uint8_t *)i_ringData.iv_pWorkBuf1,
                                  l_workBufSize,
                                  0 ),
diff --git a/src/import/chips/p10/procedures/xml/error_info/p10_qme_customize_errors.xml b/src/import/chips/p10/procedures/xml/error_info/p10_qme_customize_errors.xml
index 39e6611..4057a69 100644
--- a/src/import/chips/p10/procedures/xml/error_info/p10_qme_customize_errors.xml
+++ b/src/import/chips/p10/procedures/xml/error_info/p10_qme_customize_errors.xml
@@ -5,7 +5,7 @@
 <!--                                                                        -->
 <!-- OpenPOWER HostBoot Project                                             -->
 <!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2016,2019                        -->
+<!-- Contributors Listed Below - COPYRIGHT 2016,2020                        -->
 <!-- [+] International Business Machines Corp.                              -->
 <!--                                                                        -->
 <!--                                                                        -->
@@ -26,10 +26,10 @@
   <!-- ********************************************************************* -->
   <hwpError>
     <rc>RC_QMEC_FUNC_CALL_ARGUMENT_ERROR</rc>
-    <description>Caller bug: Some function call arguments are invalid.</description>
+    <description>Some function call arguments are invalid.</description>
     <ffdc>TARGET</ffdc>
-    <ffdc>CUSTOM_RING_OP</ffdc>
-    <ffdc>INPUT_QME_RINGS_BUF_PTR</ffdc>
+    <ffdc>CUST_RING_OP</ffdc>
+    <ffdc>INPUT_QME_RINGS_PTR</ffdc>
     <ffdc>CUST_QME_RINGS_BUF_PTR</ffdc>
     <callout>
       <procedure>CODE</procedure>
@@ -39,7 +39,7 @@
   <!-- ********************************************************************* -->
   <hwpError>
     <rc>RC_QMEC_TOR_HEADER_MISMATCH</rc>
-    <description>Caller bug: Data in TOR header does not match.</description>
+    <description>Some data in TOR header does not match.</description>
     <ffdc>TARGET</ffdc>
     <ffdc>TOR_MAGIC_QME_IN_HEADER</ffdc>
     <ffdc>TOR_MAGIC_QME_DEFINED</ffdc>
@@ -53,11 +53,11 @@
   <!-- ********************************************************************* -->
   <hwpError>
     <rc>RC_QMEC_RINGS_OUTPUT_BUFFER_TOO_SMALL</rc>
-    <description>Code bug: Input QME rings buffer is not too small.</description>
+    <description>Customized QME ring section buffer is too small.</description>
     <ffdc>TARGET</ffdc>
-    <ffdc>MAX_CUST_RINGS_BUF_SIZE</ffdc>
-    <ffdc>INPUT_QME_RINGS_BUF_SIZE</ffdc>
     <ffdc>CUST_QME_RINGS_BUF_SIZE</ffdc>
+    <ffdc>INPUT_QME_RINGS_SIZE</ffdc>
+    <ffdc>CUST_QME_RINGS_SIZE</ffdc>
     <callout>
       <procedure>CODE</procedure>
       <priority>HIGH</priority>
@@ -66,7 +66,7 @@
   <!-- ********************************************************************* -->
   <hwpError>
     <rc>RC_QMEC_TOR_SKELETON_GEN_ERROR</rc>
-    <description>Code bug: Error with calling tor_skeleton_generation().</description>
+    <description>Error with calling tor_skeleton_generation().</description>
     <ffdc>TARGET</ffdc>
     <ffdc>API_RC</ffdc>
     <ffdc>TOR_MAGIC</ffdc>
@@ -80,12 +80,16 @@
   </hwpError>
   <!-- ********************************************************************* -->
   <hwpError>
-    <rc>RC_QMEC_RINGID_GET_CHIPLETPROPS_ERROR</rc>
-    <description>Code bug: Error with calling ringid_get_chipletProps().</description>
+    <rc>RC_QMEC_RINGID_API_ERROR</rc>
+    <description>Error with calling ringid_xyz().</description>
     <ffdc>TARGET</ffdc>
     <ffdc>API_RC</ffdc>
     <ffdc>TOR_MAGIC</ffdc>
     <ffdc>TOR_VER</ffdc>
+    <ffdc>RP_INDEX</ffdc>
+    <ffdc>RING_ID</ffdc>
+    <ffdc>CHIP_ID</ffdc>
+    <ffdc>OCCURRENCE</ffdc>
     <callout>
       <procedure>CODE</procedure>
       <priority>HIGH</priority>
@@ -93,14 +97,14 @@
   </hwpError>
   <!-- ********************************************************************* -->
   <hwpError>
-    <rc>RC_QMEC_RINGID_GET_RINGID2_ERROR</rc>
-    <description>Code bug: Error with calling ringidGetRingId2().</description>
+    <rc>RC_QMEC_TOR_GET_SINGLE_RING_ERROR</rc>
+    <description>Code bug: Error with calling tor_get_single_ring().</description>
     <ffdc>TARGET</ffdc>
     <ffdc>API_RC</ffdc>
-    <ffdc>TOR_MAGIC</ffdc>
-    <ffdc>RING_INST_ID</ffdc>
-    <ffdc>INST_CASE</ffdc>
+    <ffdc>DD_LEVEL</ffdc>
     <ffdc>RING_ID</ffdc>
+    <ffdc>CHIPLET_ID</ffdc>
+    <ffdc>REM_BUF_SIZE</ffdc>
     <callout>
       <procedure>CODE</procedure>
       <priority>HIGH</priority>
@@ -108,14 +112,13 @@
   </hwpError>
   <!-- ********************************************************************* -->
   <hwpError>
-    <rc>RC_QMEC_TOR_GET_SINGLE_RING_ERROR</rc>
-    <description>Code bug: Error with calling tor_get_single_ring().</description>
+    <rc>RC_QMEC_TOR_APPEND_RING_ERROR</rc>
+    <description>Code bug: Error with calling tor_append_ring().</description>
     <ffdc>TARGET</ffdc>
     <ffdc>API_RC</ffdc>
-    <ffdc>DD_LEVEL</ffdc>
     <ffdc>RING_ID</ffdc>
-    <ffdc>CHIPLET_INST_ID</ffdc>
-    <ffdc>NEXT_RS4RING_BUF_SIZE</ffdc>
+    <ffdc>CHIPLET_ID</ffdc>
+    <ffdc>CUST_QME_RINGS_BUF_SIZE</ffdc>
     <callout>
       <procedure>CODE</procedure>
       <priority>HIGH</priority>
@@ -123,12 +126,11 @@
   </hwpError>
   <!-- ********************************************************************* -->
   <hwpError>
-    <rc>RC_QMEC_TOR_APPEND_RING_ERROR</rc>
-    <description>Code bug: Error with calling tor_append_ring().</description>
+    <rc>RC_QMEC_CODE_BUG</rc>
+    <description>Code bug: Fix code!</description>
     <ffdc>TARGET</ffdc>
     <ffdc>API_RC</ffdc>
-    <ffdc>CUST_RINGS_BUF_SIZE</ffdc>
-    <ffdc>RING_ID</ffdc>
+    <ffdc>OCCURRENCE</ffdc>
     <callout>
       <procedure>CODE</procedure>
       <priority>HIGH</priority>
diff --git a/src/import/chips/p10/utils/imageProcs/p10_ringId.H b/src/import/chips/p10/utils/imageProcs/p10_ringId.H
index b11f806..c020959 100644
--- a/src/import/chips/p10/utils/imageProcs/p10_ringId.H
+++ b/src/import/chips/p10/utils/imageProcs/p10_ringId.H
@@ -54,7 +54,7 @@
 //   circumstances exist - coordinate with infrastructure team).
 // - To allow the MVPD group to expand without affecting the ringId sequence of
 //   the EKB rings, the beginning of the EKB ring group is pushed out to
-//   RINGID_START_EKB. **This feature is currently inactive!**
+//   RINGID_START_EKB.
 //
 // p10_ring_properties.H
 // =====================
@@ -118,15 +118,55 @@ enum Chiplets
 
 const ChipletType_t QME_NUM_CHIPLETS = 1;
 
-
 #include "p10_ring_properties.H"
 
-static inline const char* ringid_get_ring_name(RingID i_id)
+
+//
+// ringid_convert_ringId_to_ringIndex()
+//
+// This function converts the enum ringId to the contiguous ringIndex that
+// we need for looking up ring metadata in the RING_PROPERTIES list.  Since
+// we have a gap between the MVPD and EKB group of rings in the main enum
+// ringId list, and since we cannot have a huge gap of empty entries in
+// the RING_PROPERTIES list as that would be a waste of Seeprom space, we
+// convert here the ringId into the ring properties (rp) index, rpIndex.
+//
+static inline const RingId_t  ringid_convert_ringId_to_rpIndex( RingId_t  i_ringId )
+{
+    if ( i_ringId >= RINGID_START_MVPD && i_ringId <= RINGID_END_MVPD )
+    {
+        return  i_ringId - RINGID_START_MVPD + RING_INDEX_START_MVPD;
+    }
+    else if ( i_ringId >= RINGID_START_EKB  && i_ringId <= RINGID_END_EKB )
+    {
+        return  i_ringId - RINGID_START_EKB + RING_INDEX_START_EKB;
+    }
+    else
+    {
+        return  UNDEFINED_RING_ID;
+    }
+}
+
+
+static inline const char* ringid_get_ring_name(RingId_t i_ringId)
 {
 #ifdef __PPE__
     return "";
 #else
-    return (i_id < NUM_RING_IDS) ? RING_PROPERTIES[i_id].ringName : "INVALID RING ID";
+
+    if ( i_ringId >= RINGID_START_MVPD && i_ringId <= RINGID_END_MVPD )
+    {
+        return RING_PROPERTIES[i_ringId - RINGID_START_MVPD + RING_INDEX_START_MVPD].ringName;
+    }
+    else if ( i_ringId >= RINGID_START_EKB  && i_ringId <= RINGID_END_EKB )
+    {
+        return RING_PROPERTIES[i_ringId - RINGID_START_EKB + RING_INDEX_START_EKB].ringName;
+    }
+    else
+    {
+        return "INVALID RING ID";
+    }
+
 #endif
 }
 
diff --git a/src/import/chips/p10/utils/imageProcs/p10_ring_id.H b/src/import/chips/p10/utils/imageProcs/p10_ring_id.H
index 7577454..efe5d51 100644
--- a/src/import/chips/p10/utils/imageProcs/p10_ring_id.H
+++ b/src/import/chips/p10/utils/imageProcs/p10_ring_id.H
@@ -198,103 +198,103 @@ enum RingID
     NUM_RING_IDS_MVPD        = 161,
 
     // EKB Rings:
-    perv_fure                = 161, //0xA1
-    sbe_fure                 = 162, //0xA2
-    occ_fure                 = 163, //0xA3
-    perv_dpll_func           = 164, //0xA4
-    perv_dpll_bndy           = 165, //0xA5
-    perv_dpll_time           = 166, //0xA6
-    perv_pll_func            = 167, //0xA7
-    perv_pll_bndy            = 168, //0xA8
-    n0_fure                  = 169, //0xA9
-    n1_fure                  = 170, //0xAA
-    n1_nmmu1_fure            = 171, //0xAB
-    pci_fure                 = 172, //0xAC
-    pci_pll_func             = 173, //0xAD
-    pci_pll_bndy             = 174, //0xAE
-    mc_fure                  = 175, //0xAF
-    mc_pll_func              = 176, //0xB0
-    mc_pll_bndy              = 177, //0xB1
-    mc_pll_bndy_bucket_0     = 178, //0xB2
-    mc_pll_bndy_bucket_1     = 179, //0xB3
-    mc_pll_bndy_bucket_2     = 180, //0xB4
-    mc_pll_bndy_bucket_3     = 181, //0xB5
-    mc_pll_bndy_bucket_4     = 182, //0xB6
-    pau0_fure                = 183, //0xB7
-    pau0_pau0_fure           = 184, //0xB8
-    pau1_fure                = 185, //0xB9
-    pau1_pau3_fure           = 186, //0xBA
-    pau2_fure                = 187, //0xBB
-    pau2_pau4_fure           = 188, //0xBC
-    pau2_pau5_fure           = 189, //0xBD
-    pau3_fure                = 190, //0xBE
-    pau3_pau6_fure           = 191, //0xBF
-    pau3_pau7_fure           = 192, //0xC0
-    iohs0_fure               = 193, //0xC1
-    iohs0_ndl_fure           = 194, //0xC2
-    iohs0_pdl_fure           = 195, //0xC3
-    iohs0_pll_func           = 196, //0xC4
-    iohs0_pll_bndy           = 197, //0xC5
-    iohs0_pll_bndy_bucket_0  = 198, //0xC6
-    iohs0_pll_bndy_bucket_1  = 199, //0xC7
-    iohs0_pll_bndy_bucket_2  = 200, //0xC8
-    iohs0_pll_bndy_bucket_3  = 201, //0xC9
-    iohs0_pll_bndy_bucket_4  = 202, //0xCA
-    iohs0_pll_bndy_bucket_5  = 203, //0xCB
-    iohs0_pll_bndy_bucket_6  = 204, //0xCC
-    iohs0_pll_bndy_bucket_7  = 205, //0xCD
-    iohs1_fure               = 206, //0xCE
-    iohs1_ndl_fure           = 207, //0xCF
-    iohs1_pdl_fure           = 208, //0xD0
-    iohs1_pll_func           = 209, //0xD1
-    iohs2_fure               = 210, //0xD2
-    iohs2_ndl_fure           = 211, //0xD3
-    iohs2_pdl_fure           = 212, //0xD4
-    iohs2_pll_func           = 213, //0xD5
-    iohs3_fure               = 214, //0xD6
-    iohs3_ndl_fure           = 215, //0xD7
-    iohs3_pdl_fure           = 216, //0xD8
-    iohs3_pll_func           = 217, //0xD9
-    iohs4_fure               = 218, //0xDA
-    iohs4_ndl_fure           = 219, //0xDB
-    iohs4_pdl_fure           = 220, //0xDC
-    iohs4_pll_func           = 221, //0xDD
-    iohs5_fure               = 222, //0xDE
-    iohs5_ndl_fure           = 223, //0xDF
-    iohs5_pdl_fure           = 224, //0xE0
-    iohs5_pll_func           = 225, //0xE1
-    iohs6_fure               = 226, //0xE2
-    iohs6_ndl_fure           = 227, //0xE3
-    iohs6_pdl_fure           = 228, //0xE4
-    iohs6_pll_func           = 229, //0xE5
-    iohs7_fure               = 230, //0xE6
-    iohs7_ndl_fure           = 231, //0xE7
-    iohs7_pdl_fure           = 232, //0xE8
-    iohs7_pll_func           = 233, //0xE9
-    eq_fure                  = 234, //0xEA
-    eq_cmsk                  = 235, //0xEB
-    eq_inex                  = 236, //0xEC
-    eq_mode                  = 237, //0xED
-    eq_clkadj_fure           = 238, //0xEE
-    eq_clkadj_cmsk           = 239, //0xEF
-    eq_clkadj_inex           = 240, //0xF0
-    eq_clkadj_mode           = 241, //0xF1
-    ec_cl2_fure              = 242, //0xF2
-    ec_cl2_cmsk              = 243, //0xF3
-    ec_cl2_inex              = 244, //0xF4
-    ec_cl2_mode              = 245, //0xF5
-    ec_mma_fure              = 246, //0xF6
-    ec_mma_cmsk              = 247, //0xF7
-    ec_mma_inex              = 248, //0xF8
-    ec_l3_fure               = 249, //0xF9
-    ec_l3_cmsk               = 250, //0xFA
-    ec_l3_inex               = 251, //0xFB
-    ec_l3_mode               = 252, //0xFC
-    n0_abst                  = 253, //0xFD
-    n1_abst                  = 254, //0xFE
-    n1_nmmu1_abst            = 255, //0xFF
-    ec_cl2_abst              = 256, //0x100
-    ec_mma_abst              = 257, //0x101
+    perv_fure                = 256, //0x100
+    sbe_fure                 = 257, //0x101
+    occ_fure                 = 258, //0x102
+    perv_dpll_func           = 259, //0x103
+    perv_dpll_bndy           = 260, //0x104
+    perv_dpll_time           = 261, //0x105
+    perv_pll_func            = 262, //0x106
+    perv_pll_bndy            = 263, //0x107
+    n0_fure                  = 264, //0x108
+    n1_fure                  = 265, //0x109
+    n1_nmmu1_fure            = 266, //0x10A
+    pci_fure                 = 267, //0x10B
+    pci_pll_func             = 268, //0x10C
+    pci_pll_bndy             = 269, //0x10D
+    mc_fure                  = 270, //0x10E
+    mc_pll_func              = 271, //0x10F
+    mc_pll_bndy              = 272, //0x110
+    mc_pll_bndy_bucket_0     = 273, //0x111
+    mc_pll_bndy_bucket_1     = 274, //0x112
+    mc_pll_bndy_bucket_2     = 275, //0x113
+    mc_pll_bndy_bucket_3     = 276, //0x114
+    mc_pll_bndy_bucket_4     = 277, //0x115
+    pau0_fure                = 278, //0x116
+    pau0_pau0_fure           = 279, //0x117
+    pau1_fure                = 280, //0x118
+    pau1_pau3_fure           = 281, //0x119
+    pau2_fure                = 282, //0x11A
+    pau2_pau4_fure           = 283, //0x11B
+    pau2_pau5_fure           = 284, //0x11C
+    pau3_fure                = 285, //0x11D
+    pau3_pau6_fure           = 286, //0x11E
+    pau3_pau7_fure           = 287, //0x11F
+    iohs0_fure               = 288, //0x120
+    iohs0_ndl_fure           = 289, //0x121
+    iohs0_pdl_fure           = 290, //0x122
+    iohs0_pll_func           = 291, //0x123
+    iohs0_pll_bndy           = 292, //0x124
+    iohs0_pll_bndy_bucket_0  = 293, //0x125
+    iohs0_pll_bndy_bucket_1  = 294, //0x126
+    iohs0_pll_bndy_bucket_2  = 295, //0x127
+    iohs0_pll_bndy_bucket_3  = 296, //0x128
+    iohs0_pll_bndy_bucket_4  = 297, //0x129
+    iohs0_pll_bndy_bucket_5  = 298, //0x12A
+    iohs0_pll_bndy_bucket_6  = 299, //0x12B
+    iohs0_pll_bndy_bucket_7  = 300, //0x12C
+    iohs1_fure               = 301, //0x12D
+    iohs1_ndl_fure           = 302, //0x12E
+    iohs1_pdl_fure           = 303, //0x12F
+    iohs1_pll_func           = 304, //0x130
+    iohs2_fure               = 305, //0x131
+    iohs2_ndl_fure           = 306, //0x132
+    iohs2_pdl_fure           = 307, //0x133
+    iohs2_pll_func           = 308, //0x134
+    iohs3_fure               = 309, //0x135
+    iohs3_ndl_fure           = 310, //0x136
+    iohs3_pdl_fure           = 311, //0x137
+    iohs3_pll_func           = 312, //0x138
+    iohs4_fure               = 313, //0x139
+    iohs4_ndl_fure           = 314, //0x13A
+    iohs4_pdl_fure           = 315, //0x13B
+    iohs4_pll_func           = 316, //0x13C
+    iohs5_fure               = 317, //0x13D
+    iohs5_ndl_fure           = 318, //0x13E
+    iohs5_pdl_fure           = 319, //0x13F
+    iohs5_pll_func           = 320, //0x140
+    iohs6_fure               = 321, //0x141
+    iohs6_ndl_fure           = 322, //0x142
+    iohs6_pdl_fure           = 323, //0x143
+    iohs6_pll_func           = 324, //0x144
+    iohs7_fure               = 325, //0x145
+    iohs7_ndl_fure           = 326, //0x146
+    iohs7_pdl_fure           = 327, //0x147
+    iohs7_pll_func           = 328, //0x148
+    eq_fure                  = 329, //0x149
+    eq_cmsk                  = 330, //0x14A
+    eq_inex                  = 331, //0x14B
+    eq_mode                  = 332, //0x14C
+    eq_clkadj_fure           = 333, //0x14D
+    eq_clkadj_cmsk           = 334, //0x14E
+    eq_clkadj_inex           = 335, //0x14F
+    eq_clkadj_mode           = 336, //0x150
+    ec_cl2_fure              = 337, //0x151
+    ec_cl2_cmsk              = 338, //0x152
+    ec_cl2_inex              = 339, //0x153
+    ec_cl2_mode              = 340, //0x154
+    ec_mma_fure              = 341, //0x155
+    ec_mma_cmsk              = 342, //0x156
+    ec_mma_inex              = 343, //0x157
+    ec_l3_fure               = 344, //0x158
+    ec_l3_cmsk               = 345, //0x159
+    ec_l3_inex               = 346, //0x15A
+    ec_l3_mode               = 347, //0x15B
+    n0_abst                  = 348, //0x15C
+    n1_abst                  = 349, //0x15D
+    n1_nmmu1_abst            = 350, //0x15E
+    ec_cl2_abst              = 351, //0x15F
+    ec_mma_abst              = 352, //0x160
     NUM_RING_IDS_EKB         = 97,
 
     NUM_RING_IDS             = 258, // = NUM_RING_IDS_MVPD + NUM_RING_IDS_EKB
diff --git a/src/import/chips/p10/utils/imageProcs/p10_ring_properties.H b/src/import/chips/p10/utils/imageProcs/p10_ring_properties.H
index 63e39f1..514eb68 100644
--- a/src/import/chips/p10/utils/imageProcs/p10_ring_properties.H
+++ b/src/import/chips/p10/utils/imageProcs/p10_ring_properties.H
@@ -26,11 +26,20 @@
 #define _P10_RING_PROPERTIES_H_
 
 static const uint8_t RING_TABLE_VERSION_DOC = 22;
-static const uint8_t RING_TABLE_VERSION_MVPD = 21;
-static const uint8_t RING_TABLE_VERSION_EKB = 21;
+static const uint8_t RING_TABLE_VERSION_MVPD = 22;
+static const uint8_t RING_TABLE_VERSION_EKB = 22;
 
+// RingID values where the MVPD and EKB rings' enum values start
+// (Used in p10_ring_id.H)
 #define RINGID_START_MVPD  (RingId_t)0
-#define RINGID_START_EKB   (RingId_t)161
+#define RINGID_END_MVPD    (RingId_t)160
+#define RINGID_START_EKB   (RingId_t)256
+#define RINGID_END_EKB     (RingId_t)352
+
+// Ring indices where the MVPD and EKB rings' metadata start
+// (Used in p10_ring_properties.H (This file))
+#define RING_INDEX_START_MVPD  (RingId_t)0
+#define RING_INDEX_START_EKB   (RingId_t)161
 
 namespace PERV
 {
@@ -600,266 +609,266 @@ static const ChipletData_t g_chipletData =
 static const RingProperties_t RING_PROPERTIES[NUM_RING_IDS] =
 {
     // MVPD Rings:
-    {"perv_occ_gptr"           , 0x01034902, PERV::perv_occ_gptr           , PERV_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 0
-    {"perv_occ_repr"           , 0x01034906, PERV::perv_occ_repr           , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 1
-    {"perv_occ_time"           , 0x01034907, PERV::perv_occ_time           , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 2
-    {"pib_repr"                , 0x01031006, PERV::pib_repr                , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 3
-    {"sbe_gptr"                , 0x01032002, PERV::sbe_gptr                , PERV_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 4
-    {"sbe_repr"                , 0x01032006, PERV::sbe_repr                , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 5
-    {"sbe_time"                , 0x01032007, PERV::sbe_time                , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 6
-    {"invalid"                 , UNDEFINED_SCOM_ADDR, UNDEFINED_RING_INDEX          , UNDEFINED_CHIPLET_TYPE, UNDEFINED_RING_CLASS                                 }, // 7
-    {"perv_dpll_gptr"          , 0x01030062, PERV::perv_dpll_gptr          , PERV_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 8
-    {"perv_pll_gptr"           , 0x01030012, PERV::perv_pll_gptr           , PERV_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 9
-    {"n0_gptr"                 , 0x02036402, N0::n0_gptr                   , N0_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 10
-    {"n0_repr"                 , 0x02036406, N0::n0_repr                   , N0_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 11
-    {"n0_time"                 , 0x02036407, N0::n0_time                   , N0_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 12
-    {"n1_gptr"                 , 0x03035402, N1::n1_gptr                   , N1_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 13
-    {"n1_repr"                 , 0x03035406, N1::n1_repr                   , N1_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 14
-    {"n1_time"                 , 0x03035407, N1::n1_time                   , N1_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 15
-    {"n1_nmmu1_gptr"           , 0x03030202, N1::n1_nmmu1_gptr             , N1_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 16
-    {"n1_nmmu1_repr"           , 0x03030206, N1::n1_nmmu1_repr             , N1_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 17
-    {"n1_nmmu1_time"           , 0x03030207, N1::n1_nmmu1_time             , N1_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 18
-    {"pci_gptr"                , 0x08037F82, PCI::pci_gptr                 , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 19
-    {"pci_repr"                , 0x08037F86, PCI::pci_repr                 , PCI_TYPE  , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 20
-    {"pci_time"                , 0x08037F87, PCI::pci_time                 , PCI_TYPE  , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 21
-    {"pci_pll_gptr"            , 0x08030012, PCI::pci_pll_gptr             , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 22
-    {"mc_gptr"                 , 0x0C036F02, MC::mc_gptr                   , MC_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 23
-    {"mc_repr"                 , 0x0C036F06, MC::mc_repr                   , MC_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 24
-    {"mc_time"                 , 0x0C036F07, MC::mc_time                   , MC_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 25
-    {"mc_pll_gptr"             , 0x0C030012, MC::mc_pll_gptr               , MC_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 26
-    {"pau0_gptr"               , 0x10034302, PAU0::pau0_gptr               , PAU0_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 27
-    {"pau0_repr"               , 0x10034306, PAU0::pau0_repr               , PAU0_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 28
-    {"pau0_time"               , 0x10034307, PAU0::pau0_time               , PAU0_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 29
-    {"pau0_pau0_gptr"          , 0x10032002, PAU0::pau0_pau0_gptr          , PAU0_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 30
-    {"pau0_pau0_repr"          , 0x10032006, PAU0::pau0_pau0_repr          , PAU0_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 31
-    {"pau0_pau0_time"          , 0x10032007, PAU0::pau0_pau0_time          , PAU0_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 32
-    {"pau1_gptr"               , 0x11034302, PAU1::pau1_gptr               , PAU1_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 33
-    {"pau1_repr"               , 0x11034306, PAU1::pau1_repr               , PAU1_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 34
-    {"pau1_time"               , 0x11034307, PAU1::pau1_time               , PAU1_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 35
-    {"pau1_pau3_gptr"          , 0x11032002, PAU1::pau1_pau3_gptr          , PAU1_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 36
-    {"pau1_pau3_repr"          , 0x11032006, PAU1::pau1_pau3_repr          , PAU1_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 37
-    {"pau1_pau3_time"          , 0x11032007, PAU1::pau1_pau3_time          , PAU1_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 38
-    {"pau2_gptr"               , 0x12034302, PAU2::pau2_gptr               , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 39
-    {"pau2_repr"               , 0x12034306, PAU2::pau2_repr               , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 40
-    {"pau2_time"               , 0x12034307, PAU2::pau2_time               , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 41
-    {"pau2_pau4_gptr"          , 0x12032002, PAU2::pau2_pau4_gptr          , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 42
-    {"pau2_pau4_repr"          , 0x12032006, PAU2::pau2_pau4_repr          , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 43
-    {"pau2_pau4_time"          , 0x12032007, PAU2::pau2_pau4_time          , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 44
-    {"pau2_pau5_gptr"          , 0x12031002, PAU2::pau2_pau5_gptr          , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 45
-    {"pau2_pau5_repr"          , 0x12031006, PAU2::pau2_pau5_repr          , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 46
-    {"pau2_pau5_time"          , 0x12031007, PAU2::pau2_pau5_time          , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 47
-    {"pau3_gptr"               , 0x13034302, PAU3::pau3_gptr               , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 48
-    {"pau3_repr"               , 0x13034306, PAU3::pau3_repr               , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 49
-    {"pau3_time"               , 0x13034307, PAU3::pau3_time               , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 50
-    {"pau3_pau6_gptr"          , 0x13032002, PAU3::pau3_pau6_gptr          , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 51
-    {"pau3_pau6_repr"          , 0x13032006, PAU3::pau3_pau6_repr          , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 52
-    {"pau3_pau6_time"          , 0x13032007, PAU3::pau3_pau6_time          , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 53
-    {"pau3_pau7_gptr"          , 0x13031002, PAU3::pau3_pau7_gptr          , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 54
-    {"pau3_pau7_repr"          , 0x13031006, PAU3::pau3_pau7_repr          , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 55
-    {"pau3_pau7_time"          , 0x13031007, PAU3::pau3_pau7_time          , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 56
-    {"iohs0_gptr"              , 0x18036002, AXON0::iohs0_gptr             , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 57
-    {"iohs0_repr"              , 0x18036006, AXON0::iohs0_repr             , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 58
-    {"iohs0_time"              , 0x18036007, AXON0::iohs0_time             , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 59
-    {"iohs0_ndl_gptr"          , 0x18030402, AXON0::iohs0_ndl_gptr         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 60
-    {"iohs0_ndl_repr"          , 0x18030406, AXON0::iohs0_ndl_repr         , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 61
-    {"iohs0_ndl_time"          , 0x18030407, AXON0::iohs0_ndl_time         , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 62
-    {"iohs0_pdl_gptr"          , 0x18030202, AXON0::iohs0_pdl_gptr         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 63
-    {"iohs0_pdl_repr"          , 0x18030206, AXON0::iohs0_pdl_repr         , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 64
-    {"iohs0_pdl_time"          , 0x18030207, AXON0::iohs0_pdl_time         , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 65
-    {"iohs0_pll_gptr"          , 0x18030012, AXON0::iohs0_pll_gptr         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 66
-    {"iohs1_gptr"              , 0x19036002, AXON1::iohs1_gptr             , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 67
-    {"iohs1_repr"              , 0x19036006, AXON1::iohs1_repr             , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 68
-    {"iohs1_time"              , 0x19036007, AXON1::iohs1_time             , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 69
-    {"iohs1_ndl_gptr"          , 0x19030402, AXON1::iohs1_ndl_gptr         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 70
-    {"iohs1_ndl_repr"          , 0x19030406, AXON1::iohs1_ndl_repr         , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 71
-    {"iohs1_ndl_time"          , 0x19030407, AXON1::iohs1_ndl_time         , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 72
-    {"iohs1_pdl_gptr"          , 0x19030202, AXON1::iohs1_pdl_gptr         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 73
-    {"iohs1_pdl_repr"          , 0x19030206, AXON1::iohs1_pdl_repr         , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 74
-    {"iohs1_pdl_time"          , 0x19030207, AXON1::iohs1_pdl_time         , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 75
-    {"iohs1_pll_gptr"          , 0x19030012, AXON1::iohs1_pll_gptr         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 76
-    {"iohs2_gptr"              , 0x1A036002, AXON2::iohs2_gptr             , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 77
-    {"iohs2_repr"              , 0x1A036006, AXON2::iohs2_repr             , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 78
-    {"iohs2_time"              , 0x1A036007, AXON2::iohs2_time             , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 79
-    {"iohs2_ndl_gptr"          , 0x1A030402, AXON2::iohs2_ndl_gptr         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 80
-    {"iohs2_ndl_repr"          , 0x1A030406, AXON2::iohs2_ndl_repr         , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 81
-    {"iohs2_ndl_time"          , 0x1A030407, AXON2::iohs2_ndl_time         , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 82
-    {"iohs2_pdl_gptr"          , 0x1A030202, AXON2::iohs2_pdl_gptr         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 83
-    {"iohs2_pdl_repr"          , 0x1A030206, AXON2::iohs2_pdl_repr         , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 84
-    {"iohs2_pdl_time"          , 0x1A030207, AXON2::iohs2_pdl_time         , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 85
-    {"iohs2_pll_gptr"          , 0x1A030012, AXON2::iohs2_pll_gptr         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 86
-    {"iohs3_gptr"              , 0x1B036002, AXON3::iohs3_gptr             , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 87
-    {"iohs3_repr"              , 0x1B036006, AXON3::iohs3_repr             , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 88
-    {"iohs3_time"              , 0x1B036007, AXON3::iohs3_time             , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 89
-    {"iohs3_ndl_gptr"          , 0x1B030402, AXON3::iohs3_ndl_gptr         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 90
-    {"iohs3_ndl_repr"          , 0x1B030406, AXON3::iohs3_ndl_repr         , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 91
-    {"iohs3_ndl_time"          , 0x1B030407, AXON3::iohs3_ndl_time         , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 92
-    {"iohs3_pdl_gptr"          , 0x1B030202, AXON3::iohs3_pdl_gptr         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 93
-    {"iohs3_pdl_repr"          , 0x1B030206, AXON3::iohs3_pdl_repr         , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 94
-    {"iohs3_pdl_time"          , 0x1B030207, AXON3::iohs3_pdl_time         , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 95
-    {"iohs3_pll_gptr"          , 0x1B030012, AXON3::iohs3_pll_gptr         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 96
-    {"iohs4_gptr"              , 0x1C036002, AXON4::iohs4_gptr             , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 97
-    {"iohs4_repr"              , 0x1C036006, AXON4::iohs4_repr             , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 98
-    {"iohs4_time"              , 0x1C036007, AXON4::iohs4_time             , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 99
-    {"iohs4_ndl_gptr"          , 0x1C030402, AXON4::iohs4_ndl_gptr         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 100
-    {"iohs4_ndl_repr"          , 0x1C030406, AXON4::iohs4_ndl_repr         , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 101
-    {"iohs4_ndl_time"          , 0x1C030407, AXON4::iohs4_ndl_time         , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 102
-    {"iohs4_pdl_gptr"          , 0x1C030202, AXON4::iohs4_pdl_gptr         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 103
-    {"iohs4_pdl_repr"          , 0x1C030206, AXON4::iohs4_pdl_repr         , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 104
-    {"iohs4_pdl_time"          , 0x1C030207, AXON4::iohs4_pdl_time         , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 105
-    {"iohs4_pll_gptr"          , 0x1C030012, AXON4::iohs4_pll_gptr         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 106
-    {"iohs5_gptr"              , 0x1D036002, AXON5::iohs5_gptr             , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 107
-    {"iohs5_repr"              , 0x1D036006, AXON5::iohs5_repr             , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 108
-    {"iohs5_time"              , 0x1D036007, AXON5::iohs5_time             , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 109
-    {"iohs5_ndl_gptr"          , 0x1D030402, AXON5::iohs5_ndl_gptr         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 110
-    {"iohs5_ndl_repr"          , 0x1D030406, AXON5::iohs5_ndl_repr         , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 111
-    {"iohs5_ndl_time"          , 0x1D030407, AXON5::iohs5_ndl_time         , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 112
-    {"iohs5_pdl_gptr"          , 0x1D030202, AXON5::iohs5_pdl_gptr         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 113
-    {"iohs5_pdl_repr"          , 0x1D030206, AXON5::iohs5_pdl_repr         , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 114
-    {"iohs5_pdl_time"          , 0x1D030207, AXON5::iohs5_pdl_time         , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 115
-    {"iohs5_pll_gptr"          , 0x1D030012, AXON5::iohs5_pll_gptr         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 116
-    {"iohs6_gptr"              , 0x1E036002, AXON6::iohs6_gptr             , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 117
-    {"iohs6_repr"              , 0x1E036006, AXON6::iohs6_repr             , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 118
-    {"iohs6_time"              , 0x1E036007, AXON6::iohs6_time             , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 119
-    {"iohs6_ndl_gptr"          , 0x1E030402, AXON6::iohs6_ndl_gptr         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 120
-    {"iohs6_ndl_repr"          , 0x1E030406, AXON6::iohs6_ndl_repr         , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 121
-    {"iohs6_ndl_time"          , 0x1E030407, AXON6::iohs6_ndl_time         , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 122
-    {"iohs6_pdl_gptr"          , 0x1E030202, AXON6::iohs6_pdl_gptr         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 123
-    {"iohs6_pdl_repr"          , 0x1E030206, AXON6::iohs6_pdl_repr         , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 124
-    {"iohs6_pdl_time"          , 0x1E030207, AXON6::iohs6_pdl_time         , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 125
-    {"iohs6_pll_gptr"          , 0x1E030012, AXON6::iohs6_pll_gptr         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 126
-    {"iohs7_gptr"              , 0x1F036002, AXON7::iohs7_gptr             , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 127
-    {"iohs7_repr"              , 0x1F036006, AXON7::iohs7_repr             , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 128
-    {"iohs7_time"              , 0x1F036007, AXON7::iohs7_time             , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 129
-    {"iohs7_ndl_gptr"          , 0x1F030402, AXON7::iohs7_ndl_gptr         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 130
-    {"iohs7_ndl_repr"          , 0x1F030406, AXON7::iohs7_ndl_repr         , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 131
-    {"iohs7_ndl_time"          , 0x1F030407, AXON7::iohs7_ndl_time         , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 132
-    {"iohs7_pdl_gptr"          , 0x1F030202, AXON7::iohs7_pdl_gptr         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 133
-    {"iohs7_pdl_repr"          , 0x1F030206, AXON7::iohs7_pdl_repr         , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 134
-    {"iohs7_pdl_time"          , 0x1F030207, AXON7::iohs7_pdl_time         , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 135
-    {"iohs7_pll_gptr"          , 0x1F030012, AXON7::iohs7_pll_gptr         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 136
-    {"eq_gptr"                 , 0x20034022, EQ::eq_gptr                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 137
-    {"eq_repr"                 , 0x20034026, EQ::eq_repr                   , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_EQ                           }, // 138
-    {"eq_time"                 , 0x20034027, EQ::eq_time                   , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 139
-    {"eq_clkadj_gptr"          , 0x20030012, EQ::eq_clkadj_gptr            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 140
-    {"eq_clkadj_repr"          , 0x20030016, EQ::eq_clkadj_repr            , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_EQ                           }, // 141
-    {"eq_clkadj_time"          , 0x20030017, EQ::eq_clkadj_time            , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 142
-    {"ec_cl2_gptr"             , 0x20032002, EQ::ec_cl2_gptr               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY | RMRK_SCAN_BY_QME    }, // 143
-    {"ec_cl2_repr"             , 0x20032006, EQ::ec_cl2_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 144
-    {"ec_cl2_time"             , 0x20032007, EQ::ec_cl2_time               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME | RMRK_SCAN_BY_QME        }, // 145
-    {"ec1_cl2_repr"            , 0x20031006, EQ::ec1_cl2_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 146
-    {"ec2_cl2_repr"            , 0x20030806, EQ::ec2_cl2_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 147
-    {"ec3_cl2_repr"            , 0x20030406, EQ::ec3_cl2_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 148
-    {"ec_mma_gptr"             , 0x20830002, EQ::ec_mma_gptr               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY | RMRK_SCAN_BY_QME    }, // 149
-    {"ec_mma_repr"             , 0x20830006, EQ::ec_mma_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 150
-    {"ec_mma_time"             , 0x20830007, EQ::ec_mma_time               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME | RMRK_SCAN_BY_QME        }, // 151
-    {"ec1_mma_repr"            , 0x20430006, EQ::ec1_mma_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 152
-    {"ec2_mma_repr"            , 0x20230006, EQ::ec2_mma_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 153
-    {"ec3_mma_repr"            , 0x20130006, EQ::ec3_mma_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 154
-    {"ec_l3_gptr"              , 0x20030202, EQ::ec_l3_gptr                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY | RMRK_SCAN_BY_QME    }, // 155
-    {"ec_l3_repr"              , 0x20030206, EQ::ec_l3_repr                , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 156
-    {"ec_l3_time"              , 0x20030207, EQ::ec_l3_time                , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME | RMRK_SCAN_BY_QME        }, // 157
-    {"ec1_l3_repr"             , 0x20030106, EQ::ec1_l3_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 158
-    {"ec2_l3_repr"             , 0x20030086, EQ::ec2_l3_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 159
-    {"ec3_l3_repr"             , 0x20030046, EQ::ec3_l3_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 160
+    {perv_occ_gptr          , "perv_occ_gptr"           , 0x01034902, PERV::perv_occ_gptr           , PERV_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 0
+    {perv_occ_repr          , "perv_occ_repr"           , 0x01034906, PERV::perv_occ_repr           , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 1
+    {perv_occ_time          , "perv_occ_time"           , 0x01034907, PERV::perv_occ_time           , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 2
+    {pib_repr               , "pib_repr"                , 0x01031006, PERV::pib_repr                , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 3
+    {sbe_gptr               , "sbe_gptr"                , 0x01032002, PERV::sbe_gptr                , PERV_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 4
+    {sbe_repr               , "sbe_repr"                , 0x01032006, PERV::sbe_repr                , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 5
+    {sbe_time               , "sbe_time"                , 0x01032007, PERV::sbe_time                , PERV_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 6
+    {HOLE_RING_ID           , "invalid"                 , UNDEFINED_SCOM_ADDR, UNDEFINED_RING_INDEX          , UNDEFINED_CHIPLET_TYPE, UNDEFINED_RING_CLASS                                 }, // 7
+    {perv_dpll_gptr         , "perv_dpll_gptr"          , 0x01030062, PERV::perv_dpll_gptr          , PERV_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 8
+    {perv_pll_gptr          , "perv_pll_gptr"           , 0x01030012, PERV::perv_pll_gptr           , PERV_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 9
+    {n0_gptr                , "n0_gptr"                 , 0x02036402, N0::n0_gptr                   , N0_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 10
+    {n0_repr                , "n0_repr"                 , 0x02036406, N0::n0_repr                   , N0_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 11
+    {n0_time                , "n0_time"                 , 0x02036407, N0::n0_time                   , N0_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 12
+    {n1_gptr                , "n1_gptr"                 , 0x03035402, N1::n1_gptr                   , N1_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 13
+    {n1_repr                , "n1_repr"                 , 0x03035406, N1::n1_repr                   , N1_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 14
+    {n1_time                , "n1_time"                 , 0x03035407, N1::n1_time                   , N1_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 15
+    {n1_nmmu1_gptr          , "n1_nmmu1_gptr"           , 0x03030202, N1::n1_nmmu1_gptr             , N1_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 16
+    {n1_nmmu1_repr          , "n1_nmmu1_repr"           , 0x03030206, N1::n1_nmmu1_repr             , N1_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 17
+    {n1_nmmu1_time          , "n1_nmmu1_time"           , 0x03030207, N1::n1_nmmu1_time             , N1_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 18
+    {pci_gptr               , "pci_gptr"                , 0x08037F82, PCI::pci_gptr                 , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 19
+    {pci_repr               , "pci_repr"                , 0x08037F86, PCI::pci_repr                 , PCI_TYPE  , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 20
+    {pci_time               , "pci_time"                , 0x08037F87, PCI::pci_time                 , PCI_TYPE  , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 21
+    {pci_pll_gptr           , "pci_pll_gptr"            , 0x08030012, PCI::pci_pll_gptr             , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 22
+    {mc_gptr                , "mc_gptr"                 , 0x0C036F02, MC::mc_gptr                   , MC_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 23
+    {mc_repr                , "mc_repr"                 , 0x0C036F06, MC::mc_repr                   , MC_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 24
+    {mc_time                , "mc_time"                 , 0x0C036F07, MC::mc_time                   , MC_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 25
+    {mc_pll_gptr            , "mc_pll_gptr"             , 0x0C030012, MC::mc_pll_gptr               , MC_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 26
+    {pau0_gptr              , "pau0_gptr"               , 0x10034302, PAU0::pau0_gptr               , PAU0_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 27
+    {pau0_repr              , "pau0_repr"               , 0x10034306, PAU0::pau0_repr               , PAU0_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 28
+    {pau0_time              , "pau0_time"               , 0x10034307, PAU0::pau0_time               , PAU0_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 29
+    {pau0_pau0_gptr         , "pau0_pau0_gptr"          , 0x10032002, PAU0::pau0_pau0_gptr          , PAU0_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 30
+    {pau0_pau0_repr         , "pau0_pau0_repr"          , 0x10032006, PAU0::pau0_pau0_repr          , PAU0_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 31
+    {pau0_pau0_time         , "pau0_pau0_time"          , 0x10032007, PAU0::pau0_pau0_time          , PAU0_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 32
+    {pau1_gptr              , "pau1_gptr"               , 0x11034302, PAU1::pau1_gptr               , PAU1_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 33
+    {pau1_repr              , "pau1_repr"               , 0x11034306, PAU1::pau1_repr               , PAU1_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 34
+    {pau1_time              , "pau1_time"               , 0x11034307, PAU1::pau1_time               , PAU1_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 35
+    {pau1_pau3_gptr         , "pau1_pau3_gptr"          , 0x11032002, PAU1::pau1_pau3_gptr          , PAU1_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 36
+    {pau1_pau3_repr         , "pau1_pau3_repr"          , 0x11032006, PAU1::pau1_pau3_repr          , PAU1_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 37
+    {pau1_pau3_time         , "pau1_pau3_time"          , 0x11032007, PAU1::pau1_pau3_time          , PAU1_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 38
+    {pau2_gptr              , "pau2_gptr"               , 0x12034302, PAU2::pau2_gptr               , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 39
+    {pau2_repr              , "pau2_repr"               , 0x12034306, PAU2::pau2_repr               , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 40
+    {pau2_time              , "pau2_time"               , 0x12034307, PAU2::pau2_time               , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 41
+    {pau2_pau4_gptr         , "pau2_pau4_gptr"          , 0x12032002, PAU2::pau2_pau4_gptr          , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 42
+    {pau2_pau4_repr         , "pau2_pau4_repr"          , 0x12032006, PAU2::pau2_pau4_repr          , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 43
+    {pau2_pau4_time         , "pau2_pau4_time"          , 0x12032007, PAU2::pau2_pau4_time          , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 44
+    {pau2_pau5_gptr         , "pau2_pau5_gptr"          , 0x12031002, PAU2::pau2_pau5_gptr          , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 45
+    {pau2_pau5_repr         , "pau2_pau5_repr"          , 0x12031006, PAU2::pau2_pau5_repr          , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 46
+    {pau2_pau5_time         , "pau2_pau5_time"          , 0x12031007, PAU2::pau2_pau5_time          , PAU2_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 47
+    {pau3_gptr              , "pau3_gptr"               , 0x13034302, PAU3::pau3_gptr               , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 48
+    {pau3_repr              , "pau3_repr"               , 0x13034306, PAU3::pau3_repr               , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 49
+    {pau3_time              , "pau3_time"               , 0x13034307, PAU3::pau3_time               , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 50
+    {pau3_pau6_gptr         , "pau3_pau6_gptr"          , 0x13032002, PAU3::pau3_pau6_gptr          , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 51
+    {pau3_pau6_repr         , "pau3_pau6_repr"          , 0x13032006, PAU3::pau3_pau6_repr          , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 52
+    {pau3_pau6_time         , "pau3_pau6_time"          , 0x13032007, PAU3::pau3_pau6_time          , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 53
+    {pau3_pau7_gptr         , "pau3_pau7_gptr"          , 0x13031002, PAU3::pau3_pau7_gptr          , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 54
+    {pau3_pau7_repr         , "pau3_pau7_repr"          , 0x13031006, PAU3::pau3_pau7_repr          , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 55
+    {pau3_pau7_time         , "pau3_pau7_time"          , 0x13031007, PAU3::pau3_pau7_time          , PAU3_TYPE , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 56
+    {iohs0_gptr             , "iohs0_gptr"              , 0x18036002, AXON0::iohs0_gptr             , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 57
+    {iohs0_repr             , "iohs0_repr"              , 0x18036006, AXON0::iohs0_repr             , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 58
+    {iohs0_time             , "iohs0_time"              , 0x18036007, AXON0::iohs0_time             , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 59
+    {iohs0_ndl_gptr         , "iohs0_ndl_gptr"          , 0x18030402, AXON0::iohs0_ndl_gptr         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 60
+    {iohs0_ndl_repr         , "iohs0_ndl_repr"          , 0x18030406, AXON0::iohs0_ndl_repr         , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 61
+    {iohs0_ndl_time         , "iohs0_ndl_time"          , 0x18030407, AXON0::iohs0_ndl_time         , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 62
+    {iohs0_pdl_gptr         , "iohs0_pdl_gptr"          , 0x18030202, AXON0::iohs0_pdl_gptr         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 63
+    {iohs0_pdl_repr         , "iohs0_pdl_repr"          , 0x18030206, AXON0::iohs0_pdl_repr         , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 64
+    {iohs0_pdl_time         , "iohs0_pdl_time"          , 0x18030207, AXON0::iohs0_pdl_time         , AXON0_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 65
+    {iohs0_pll_gptr         , "iohs0_pll_gptr"          , 0x18030012, AXON0::iohs0_pll_gptr         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 66
+    {iohs1_gptr             , "iohs1_gptr"              , 0x19036002, AXON1::iohs1_gptr             , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 67
+    {iohs1_repr             , "iohs1_repr"              , 0x19036006, AXON1::iohs1_repr             , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 68
+    {iohs1_time             , "iohs1_time"              , 0x19036007, AXON1::iohs1_time             , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 69
+    {iohs1_ndl_gptr         , "iohs1_ndl_gptr"          , 0x19030402, AXON1::iohs1_ndl_gptr         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 70
+    {iohs1_ndl_repr         , "iohs1_ndl_repr"          , 0x19030406, AXON1::iohs1_ndl_repr         , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 71
+    {iohs1_ndl_time         , "iohs1_ndl_time"          , 0x19030407, AXON1::iohs1_ndl_time         , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 72
+    {iohs1_pdl_gptr         , "iohs1_pdl_gptr"          , 0x19030202, AXON1::iohs1_pdl_gptr         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 73
+    {iohs1_pdl_repr         , "iohs1_pdl_repr"          , 0x19030206, AXON1::iohs1_pdl_repr         , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 74
+    {iohs1_pdl_time         , "iohs1_pdl_time"          , 0x19030207, AXON1::iohs1_pdl_time         , AXON1_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 75
+    {iohs1_pll_gptr         , "iohs1_pll_gptr"          , 0x19030012, AXON1::iohs1_pll_gptr         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 76
+    {iohs2_gptr             , "iohs2_gptr"              , 0x1A036002, AXON2::iohs2_gptr             , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 77
+    {iohs2_repr             , "iohs2_repr"              , 0x1A036006, AXON2::iohs2_repr             , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 78
+    {iohs2_time             , "iohs2_time"              , 0x1A036007, AXON2::iohs2_time             , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 79
+    {iohs2_ndl_gptr         , "iohs2_ndl_gptr"          , 0x1A030402, AXON2::iohs2_ndl_gptr         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 80
+    {iohs2_ndl_repr         , "iohs2_ndl_repr"          , 0x1A030406, AXON2::iohs2_ndl_repr         , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 81
+    {iohs2_ndl_time         , "iohs2_ndl_time"          , 0x1A030407, AXON2::iohs2_ndl_time         , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 82
+    {iohs2_pdl_gptr         , "iohs2_pdl_gptr"          , 0x1A030202, AXON2::iohs2_pdl_gptr         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 83
+    {iohs2_pdl_repr         , "iohs2_pdl_repr"          , 0x1A030206, AXON2::iohs2_pdl_repr         , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 84
+    {iohs2_pdl_time         , "iohs2_pdl_time"          , 0x1A030207, AXON2::iohs2_pdl_time         , AXON2_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 85
+    {iohs2_pll_gptr         , "iohs2_pll_gptr"          , 0x1A030012, AXON2::iohs2_pll_gptr         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 86
+    {iohs3_gptr             , "iohs3_gptr"              , 0x1B036002, AXON3::iohs3_gptr             , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 87
+    {iohs3_repr             , "iohs3_repr"              , 0x1B036006, AXON3::iohs3_repr             , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 88
+    {iohs3_time             , "iohs3_time"              , 0x1B036007, AXON3::iohs3_time             , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 89
+    {iohs3_ndl_gptr         , "iohs3_ndl_gptr"          , 0x1B030402, AXON3::iohs3_ndl_gptr         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 90
+    {iohs3_ndl_repr         , "iohs3_ndl_repr"          , 0x1B030406, AXON3::iohs3_ndl_repr         , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 91
+    {iohs3_ndl_time         , "iohs3_ndl_time"          , 0x1B030407, AXON3::iohs3_ndl_time         , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 92
+    {iohs3_pdl_gptr         , "iohs3_pdl_gptr"          , 0x1B030202, AXON3::iohs3_pdl_gptr         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 93
+    {iohs3_pdl_repr         , "iohs3_pdl_repr"          , 0x1B030206, AXON3::iohs3_pdl_repr         , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 94
+    {iohs3_pdl_time         , "iohs3_pdl_time"          , 0x1B030207, AXON3::iohs3_pdl_time         , AXON3_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 95
+    {iohs3_pll_gptr         , "iohs3_pll_gptr"          , 0x1B030012, AXON3::iohs3_pll_gptr         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 96
+    {iohs4_gptr             , "iohs4_gptr"              , 0x1C036002, AXON4::iohs4_gptr             , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 97
+    {iohs4_repr             , "iohs4_repr"              , 0x1C036006, AXON4::iohs4_repr             , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 98
+    {iohs4_time             , "iohs4_time"              , 0x1C036007, AXON4::iohs4_time             , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 99
+    {iohs4_ndl_gptr         , "iohs4_ndl_gptr"          , 0x1C030402, AXON4::iohs4_ndl_gptr         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 100
+    {iohs4_ndl_repr         , "iohs4_ndl_repr"          , 0x1C030406, AXON4::iohs4_ndl_repr         , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 101
+    {iohs4_ndl_time         , "iohs4_ndl_time"          , 0x1C030407, AXON4::iohs4_ndl_time         , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 102
+    {iohs4_pdl_gptr         , "iohs4_pdl_gptr"          , 0x1C030202, AXON4::iohs4_pdl_gptr         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 103
+    {iohs4_pdl_repr         , "iohs4_pdl_repr"          , 0x1C030206, AXON4::iohs4_pdl_repr         , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 104
+    {iohs4_pdl_time         , "iohs4_pdl_time"          , 0x1C030207, AXON4::iohs4_pdl_time         , AXON4_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 105
+    {iohs4_pll_gptr         , "iohs4_pll_gptr"          , 0x1C030012, AXON4::iohs4_pll_gptr         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 106
+    {iohs5_gptr             , "iohs5_gptr"              , 0x1D036002, AXON5::iohs5_gptr             , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 107
+    {iohs5_repr             , "iohs5_repr"              , 0x1D036006, AXON5::iohs5_repr             , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 108
+    {iohs5_time             , "iohs5_time"              , 0x1D036007, AXON5::iohs5_time             , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 109
+    {iohs5_ndl_gptr         , "iohs5_ndl_gptr"          , 0x1D030402, AXON5::iohs5_ndl_gptr         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 110
+    {iohs5_ndl_repr         , "iohs5_ndl_repr"          , 0x1D030406, AXON5::iohs5_ndl_repr         , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 111
+    {iohs5_ndl_time         , "iohs5_ndl_time"          , 0x1D030407, AXON5::iohs5_ndl_time         , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 112
+    {iohs5_pdl_gptr         , "iohs5_pdl_gptr"          , 0x1D030202, AXON5::iohs5_pdl_gptr         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 113
+    {iohs5_pdl_repr         , "iohs5_pdl_repr"          , 0x1D030206, AXON5::iohs5_pdl_repr         , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 114
+    {iohs5_pdl_time         , "iohs5_pdl_time"          , 0x1D030207, AXON5::iohs5_pdl_time         , AXON5_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 115
+    {iohs5_pll_gptr         , "iohs5_pll_gptr"          , 0x1D030012, AXON5::iohs5_pll_gptr         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 116
+    {iohs6_gptr             , "iohs6_gptr"              , 0x1E036002, AXON6::iohs6_gptr             , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 117
+    {iohs6_repr             , "iohs6_repr"              , 0x1E036006, AXON6::iohs6_repr             , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 118
+    {iohs6_time             , "iohs6_time"              , 0x1E036007, AXON6::iohs6_time             , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 119
+    {iohs6_ndl_gptr         , "iohs6_ndl_gptr"          , 0x1E030402, AXON6::iohs6_ndl_gptr         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 120
+    {iohs6_ndl_repr         , "iohs6_ndl_repr"          , 0x1E030406, AXON6::iohs6_ndl_repr         , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 121
+    {iohs6_ndl_time         , "iohs6_ndl_time"          , 0x1E030407, AXON6::iohs6_ndl_time         , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 122
+    {iohs6_pdl_gptr         , "iohs6_pdl_gptr"          , 0x1E030202, AXON6::iohs6_pdl_gptr         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 123
+    {iohs6_pdl_repr         , "iohs6_pdl_repr"          , 0x1E030206, AXON6::iohs6_pdl_repr         , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 124
+    {iohs6_pdl_time         , "iohs6_pdl_time"          , 0x1E030207, AXON6::iohs6_pdl_time         , AXON6_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 125
+    {iohs6_pll_gptr         , "iohs6_pll_gptr"          , 0x1E030012, AXON6::iohs6_pll_gptr         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 126
+    {iohs7_gptr             , "iohs7_gptr"              , 0x1F036002, AXON7::iohs7_gptr             , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 127
+    {iohs7_repr             , "iohs7_repr"              , 0x1F036006, AXON7::iohs7_repr             , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 128
+    {iohs7_time             , "iohs7_time"              , 0x1F036007, AXON7::iohs7_time             , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 129
+    {iohs7_ndl_gptr         , "iohs7_ndl_gptr"          , 0x1F030402, AXON7::iohs7_ndl_gptr         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 130
+    {iohs7_ndl_repr         , "iohs7_ndl_repr"          , 0x1F030406, AXON7::iohs7_ndl_repr         , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 131
+    {iohs7_ndl_time         , "iohs7_ndl_time"          , 0x1F030407, AXON7::iohs7_ndl_time         , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 132
+    {iohs7_pdl_gptr         , "iohs7_pdl_gptr"          , 0x1F030202, AXON7::iohs7_pdl_gptr         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 133
+    {iohs7_pdl_repr         , "iohs7_pdl_repr"          , 0x1F030206, AXON7::iohs7_pdl_repr         , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDR_NEST                         }, // 134
+    {iohs7_pdl_time         , "iohs7_pdl_time"          , 0x1F030207, AXON7::iohs7_pdl_time         , AXON7_TYPE, RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 135
+    {iohs7_pll_gptr         , "iohs7_pll_gptr"          , 0x1F030012, AXON7::iohs7_pll_gptr         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 136
+    {eq_gptr                , "eq_gptr"                 , 0x20034022, EQ::eq_gptr                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 137
+    {eq_repr                , "eq_repr"                 , 0x20034026, EQ::eq_repr                   , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_EQ                           }, // 138
+    {eq_time                , "eq_time"                 , 0x20034027, EQ::eq_time                   , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 139
+    {eq_clkadj_gptr         , "eq_clkadj_gptr"          , 0x20030012, EQ::eq_clkadj_gptr            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY                     }, // 140
+    {eq_clkadj_repr         , "eq_clkadj_repr"          , 0x20030016, EQ::eq_clkadj_repr            , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_EQ                           }, // 141
+    {eq_clkadj_time         , "eq_clkadj_time"          , 0x20030017, EQ::eq_clkadj_time            , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME                         }, // 142
+    {ec_cl2_gptr            , "ec_cl2_gptr"             , 0x20032002, EQ::ec_cl2_gptr               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY | RMRK_SCAN_BY_QME    }, // 143
+    {ec_cl2_repr            , "ec_cl2_repr"             , 0x20032006, EQ::ec_cl2_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 144
+    {ec_cl2_time            , "ec_cl2_time"             , 0x20032007, EQ::ec_cl2_time               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME | RMRK_SCAN_BY_QME        }, // 145
+    {ec1_cl2_repr           , "ec1_cl2_repr"            , 0x20031006, EQ::ec1_cl2_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 146
+    {ec2_cl2_repr           , "ec2_cl2_repr"            , 0x20030806, EQ::ec2_cl2_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 147
+    {ec3_cl2_repr           , "ec3_cl2_repr"            , 0x20030406, EQ::ec3_cl2_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 148
+    {ec_mma_gptr            , "ec_mma_gptr"             , 0x20830002, EQ::ec_mma_gptr               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY | RMRK_SCAN_BY_QME    }, // 149
+    {ec_mma_repr            , "ec_mma_repr"             , 0x20830006, EQ::ec_mma_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 150
+    {ec_mma_time            , "ec_mma_time"             , 0x20830007, EQ::ec_mma_time               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME | RMRK_SCAN_BY_QME        }, // 151
+    {ec1_mma_repr           , "ec1_mma_repr"            , 0x20430006, EQ::ec1_mma_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 152
+    {ec2_mma_repr           , "ec2_mma_repr"            , 0x20230006, EQ::ec2_mma_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 153
+    {ec3_mma_repr           , "ec3_mma_repr"            , 0x20130006, EQ::ec3_mma_repr              , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 154
+    {ec_l3_gptr             , "ec_l3_gptr"              , 0x20030202, EQ::ec_l3_gptr                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_MVPD_PDG_OVLY | RMRK_SCAN_BY_QME    }, // 155
+    {ec_l3_repr             , "ec_l3_repr"              , 0x20030206, EQ::ec_l3_repr                , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 156
+    {ec_l3_time             , "ec_l3_time"              , 0x20030207, EQ::ec_l3_time                , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDG_TIME | RMRK_SCAN_BY_QME        }, // 157
+    {ec1_l3_repr            , "ec1_l3_repr"             , 0x20030106, EQ::ec1_l3_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 158
+    {ec2_l3_repr            , "ec2_l3_repr"             , 0x20030086, EQ::ec2_l3_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 159
+    {ec3_l3_repr            , "ec3_l3_repr"             , 0x20030046, EQ::ec3_l3_repr               , EQ_TYPE   , RMRK_ROOT | RCLS_MVPD_PDR_CORE | RMRK_SCAN_BY_QME        }, // 160
 
     // EKB Rings:
-    {"perv_fure"               , 0x0103410F, PERV::perv_fure               , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 161
-    {"sbe_fure"                , 0x0103200F, PERV::sbe_fure                , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 162
-    {"occ_fure"                , 0x0103080F, PERV::occ_fure                , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 163
-    {"perv_dpll_func"          , 0x01030060, PERV::perv_dpll_func          , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 164
-    {"perv_dpll_bndy"          , 0x01030068, PERV::perv_dpll_bndy          , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 165
-    {"perv_dpll_time"          , 0x01030067, PERV::perv_dpll_time          , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 166
-    {"perv_pll_func"           , 0x01030010, PERV::perv_pll_func           , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 167
-    {"perv_pll_bndy"           , 0x01030018, PERV::perv_pll_bndy           , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 168
-    {"n0_fure"                 , 0x0203640F, N0::n0_fure                   , N0_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 169
-    {"n1_fure"                 , 0x0303540F, N1::n1_fure                   , N1_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 170
-    {"n1_nmmu1_fure"           , 0x0303020F, N1::n1_nmmu1_fure             , N1_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 171
-    {"pci_fure"                , 0x08037F8F, PCI::pci_fure                 , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 172
-    {"pci_pll_func"            , 0x08030010, PCI::pci_pll_func             , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 173
-    {"pci_pll_bndy"            , 0x08030018, PCI::pci_pll_bndy             , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 174
-    {"mc_fure"                 , 0x0C036F0F, MC::mc_fure                   , MC_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 175
-    {"mc_pll_func"             , 0x0C030010, MC::mc_pll_func               , MC_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 176
-    {"mc_pll_bndy"             , 0x0C030018, MC::mc_pll_bndy               , MC_TYPE   , RMRK_ROOT | RMRK_HAS_DERIVS | RCLS_EKB_RINGS             }, // 177
-    {"mc_pll_bndy_bucket_0"    , 0x0C030018, MC::mc_pll_bndy_bucket_0      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 178
-    {"mc_pll_bndy_bucket_1"    , 0x0C030018, MC::mc_pll_bndy_bucket_1      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 179
-    {"mc_pll_bndy_bucket_2"    , 0x0C030018, MC::mc_pll_bndy_bucket_2      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 180
-    {"mc_pll_bndy_bucket_3"    , 0x0C030018, MC::mc_pll_bndy_bucket_3      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 181
-    {"mc_pll_bndy_bucket_4"    , 0x0C030018, MC::mc_pll_bndy_bucket_4      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 182
-    {"pau0_fure"               , 0x1003430F, PAU0::pau0_fure               , PAU0_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 183
-    {"pau0_pau0_fure"          , 0x1003200F, PAU0::pau0_pau0_fure          , PAU0_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 184
-    {"pau1_fure"               , 0x1103430F, PAU1::pau1_fure               , PAU1_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 185
-    {"pau1_pau3_fure"          , 0x1103200F, PAU1::pau1_pau3_fure          , PAU1_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 186
-    {"pau2_fure"               , 0x1203430F, PAU2::pau2_fure               , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 187
-    {"pau2_pau4_fure"          , 0x1203200F, PAU2::pau2_pau4_fure          , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 188
-    {"pau2_pau5_fure"          , 0x1203100F, PAU2::pau2_pau5_fure          , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 189
-    {"pau3_fure"               , 0x1303430F, PAU3::pau3_fure               , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 190
-    {"pau3_pau6_fure"          , 0x1303200F, PAU3::pau3_pau6_fure          , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 191
-    {"pau3_pau7_fure"          , 0x1303100F, PAU3::pau3_pau7_fure          , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 192
-    {"iohs0_fure"              , 0x1803600F, AXON0::iohs0_fure             , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 193
-    {"iohs0_ndl_fure"          , 0x1803040F, AXON0::iohs0_ndl_fure         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 194
-    {"iohs0_pdl_fure"          , 0x1803020F, AXON0::iohs0_pdl_fure         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 195
-    {"iohs0_pll_func"          , 0x18030010, AXON0::iohs0_pll_func         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 196
-    {"iohs0_pll_bndy"          , 0x18030018, AXON0::iohs0_pll_bndy         , AXON0_TYPE, RMRK_ROOT | RMRK_HAS_DERIVS | RCLS_EKB_RINGS             }, // 197
-    {"iohs0_pll_bndy_bucket_0" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_0, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 198
-    {"iohs0_pll_bndy_bucket_1" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_1, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 199
-    {"iohs0_pll_bndy_bucket_2" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_2, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 200
-    {"iohs0_pll_bndy_bucket_3" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_3, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 201
-    {"iohs0_pll_bndy_bucket_4" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_4, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 202
-    {"iohs0_pll_bndy_bucket_5" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_5, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 203
-    {"iohs0_pll_bndy_bucket_6" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_6, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 204
-    {"iohs0_pll_bndy_bucket_7" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_7, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 205
-    {"iohs1_fure"              , 0x1903600F, AXON1::iohs1_fure             , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 206
-    {"iohs1_ndl_fure"          , 0x1903040F, AXON1::iohs1_ndl_fure         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 207
-    {"iohs1_pdl_fure"          , 0x1903020F, AXON1::iohs1_pdl_fure         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 208
-    {"iohs1_pll_func"          , 0x19030010, AXON1::iohs1_pll_func         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 209
-    {"iohs2_fure"              , 0x1A03600F, AXON2::iohs2_fure             , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 210
-    {"iohs2_ndl_fure"          , 0x1A03040F, AXON2::iohs2_ndl_fure         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 211
-    {"iohs2_pdl_fure"          , 0x1A03020F, AXON2::iohs2_pdl_fure         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 212
-    {"iohs2_pll_func"          , 0x1A030010, AXON2::iohs2_pll_func         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 213
-    {"iohs3_fure"              , 0x1B03600F, AXON3::iohs3_fure             , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 214
-    {"iohs3_ndl_fure"          , 0x1B03040F, AXON3::iohs3_ndl_fure         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 215
-    {"iohs3_pdl_fure"          , 0x1B03020F, AXON3::iohs3_pdl_fure         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 216
-    {"iohs3_pll_func"          , 0x1B030010, AXON3::iohs3_pll_func         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 217
-    {"iohs4_fure"              , 0x1C03600F, AXON4::iohs4_fure             , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 218
-    {"iohs4_ndl_fure"          , 0x1C03040F, AXON4::iohs4_ndl_fure         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 219
-    {"iohs4_pdl_fure"          , 0x1C03020F, AXON4::iohs4_pdl_fure         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 220
-    {"iohs4_pll_func"          , 0x1C030010, AXON4::iohs4_pll_func         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 221
-    {"iohs5_fure"              , 0x1D03600F, AXON5::iohs5_fure             , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 222
-    {"iohs5_ndl_fure"          , 0x1D03040F, AXON5::iohs5_ndl_fure         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 223
-    {"iohs5_pdl_fure"          , 0x1D03020F, AXON5::iohs5_pdl_fure         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 224
-    {"iohs5_pll_func"          , 0x1D030010, AXON5::iohs5_pll_func         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 225
-    {"iohs6_fure"              , 0x1E03600F, AXON6::iohs6_fure             , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 226
-    {"iohs6_ndl_fure"          , 0x1E03040F, AXON6::iohs6_ndl_fure         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 227
-    {"iohs6_pdl_fure"          , 0x1E03020F, AXON6::iohs6_pdl_fure         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 228
-    {"iohs6_pll_func"          , 0x1E030010, AXON6::iohs6_pll_func         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 229
-    {"iohs7_fure"              , 0x1F03600F, AXON7::iohs7_fure             , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 230
-    {"iohs7_ndl_fure"          , 0x1F03040F, AXON7::iohs7_ndl_fure         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 231
-    {"iohs7_pdl_fure"          , 0x1F03020F, AXON7::iohs7_pdl_fure         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 232
-    {"iohs7_pll_func"          , 0x1F030010, AXON7::iohs7_pll_func         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 233
-    {"eq_fure"                 , 0x2003402F, EQ::eq_fure                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 234
-    {"eq_cmsk"                 , 0x2003402A, EQ::eq_cmsk                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 235
-    {"eq_inex"                 , 0x2003402B, EQ::eq_inex                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 236
-    {"eq_mode"                 , 0x20034021, EQ::eq_mode                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 237
-    {"eq_clkadj_fure"          , 0x2003001F, EQ::eq_clkadj_fure            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 238
-    {"eq_clkadj_cmsk"          , 0x2003001A, EQ::eq_clkadj_cmsk            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 239
-    {"eq_clkadj_inex"          , 0x2003001B, EQ::eq_clkadj_inex            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 240
-    {"eq_clkadj_mode"          , 0x20030011, EQ::eq_clkadj_mode            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 241
-    {"ec_cl2_fure"             , 0x2003200F, EQ::ec_cl2_fure               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 242
-    {"ec_cl2_cmsk"             , 0x2003200A, EQ::ec_cl2_cmsk               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 243
-    {"ec_cl2_inex"             , 0x2003200B, EQ::ec_cl2_inex               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 244
-    {"ec_cl2_mode"             , 0x20032001, EQ::ec_cl2_mode               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 245
-    {"ec_mma_fure"             , 0x2083000F, EQ::ec_mma_fure               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 246
-    {"ec_mma_cmsk"             , 0x2083000A, EQ::ec_mma_cmsk               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 247
-    {"ec_mma_inex"             , 0x2083000B, EQ::ec_mma_inex               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 248
-    {"ec_l3_fure"              , 0x2003020F, EQ::ec_l3_fure                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 249
-    {"ec_l3_cmsk"              , 0x2003020A, EQ::ec_l3_cmsk                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 250
-    {"ec_l3_inex"              , 0x2003020B, EQ::ec_l3_inex                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 251
-    {"ec_l3_mode"              , 0x20030201, EQ::ec_l3_mode                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 252
-    {"n0_abst"                 , 0x02036405, N0::n0_abst                   , N0_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                           }, // 253
-    {"n1_abst"                 , 0x03035405, N1::n1_abst                   , N1_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                           }, // 254
-    {"n1_nmmu1_abst"           , 0x03030205, N1::n1_nmmu1_abst             , N1_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                           }, // 255
-    {"ec_cl2_abst"             , 0x20032005, EQ::ec_cl2_abst               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                           }, // 256
-    {"ec_mma_abst"             , 0x20830005, EQ::ec_mma_abst               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                           }, // 257
+    {perv_fure              , "perv_fure"               , 0x0103410F, PERV::perv_fure               , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 256
+    {sbe_fure               , "sbe_fure"                , 0x0103200F, PERV::sbe_fure                , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 257
+    {occ_fure               , "occ_fure"                , 0x0103080F, PERV::occ_fure                , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 258
+    {perv_dpll_func         , "perv_dpll_func"          , 0x01030060, PERV::perv_dpll_func          , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 259
+    {perv_dpll_bndy         , "perv_dpll_bndy"          , 0x01030068, PERV::perv_dpll_bndy          , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 260
+    {perv_dpll_time         , "perv_dpll_time"          , 0x01030067, PERV::perv_dpll_time          , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 261
+    {perv_pll_func          , "perv_pll_func"           , 0x01030010, PERV::perv_pll_func           , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 262
+    {perv_pll_bndy          , "perv_pll_bndy"           , 0x01030018, PERV::perv_pll_bndy           , PERV_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 263
+    {n0_fure                , "n0_fure"                 , 0x0203640F, N0::n0_fure                   , N0_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 264
+    {n1_fure                , "n1_fure"                 , 0x0303540F, N1::n1_fure                   , N1_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 265
+    {n1_nmmu1_fure          , "n1_nmmu1_fure"           , 0x0303020F, N1::n1_nmmu1_fure             , N1_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 266
+    {pci_fure               , "pci_fure"                , 0x08037F8F, PCI::pci_fure                 , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 267
+    {pci_pll_func           , "pci_pll_func"            , 0x08030010, PCI::pci_pll_func             , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 268
+    {pci_pll_bndy           , "pci_pll_bndy"            , 0x08030018, PCI::pci_pll_bndy             , PCI_TYPE  , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 269
+    {mc_fure                , "mc_fure"                 , 0x0C036F0F, MC::mc_fure                   , MC_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 270
+    {mc_pll_func            , "mc_pll_func"             , 0x0C030010, MC::mc_pll_func               , MC_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 271
+    {mc_pll_bndy            , "mc_pll_bndy"             , 0x0C030018, MC::mc_pll_bndy               , MC_TYPE   , RMRK_ROOT | RMRK_HAS_DERIVS | RCLS_EKB_RINGS             }, // 272
+    {mc_pll_bndy_bucket_0   , "mc_pll_bndy_bucket_0"    , 0x0C030018, MC::mc_pll_bndy_bucket_0      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 273
+    {mc_pll_bndy_bucket_1   , "mc_pll_bndy_bucket_1"    , 0x0C030018, MC::mc_pll_bndy_bucket_1      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 274
+    {mc_pll_bndy_bucket_2   , "mc_pll_bndy_bucket_2"    , 0x0C030018, MC::mc_pll_bndy_bucket_2      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 275
+    {mc_pll_bndy_bucket_3   , "mc_pll_bndy_bucket_3"    , 0x0C030018, MC::mc_pll_bndy_bucket_3      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 276
+    {mc_pll_bndy_bucket_4   , "mc_pll_bndy_bucket_4"    , 0x0C030018, MC::mc_pll_bndy_bucket_4      , MC_TYPE   , RCLS_EKB_RINGS                                       }, // 277
+    {pau0_fure              , "pau0_fure"               , 0x1003430F, PAU0::pau0_fure               , PAU0_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 278
+    {pau0_pau0_fure         , "pau0_pau0_fure"          , 0x1003200F, PAU0::pau0_pau0_fure          , PAU0_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 279
+    {pau1_fure              , "pau1_fure"               , 0x1103430F, PAU1::pau1_fure               , PAU1_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 280
+    {pau1_pau3_fure         , "pau1_pau3_fure"          , 0x1103200F, PAU1::pau1_pau3_fure          , PAU1_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 281
+    {pau2_fure              , "pau2_fure"               , 0x1203430F, PAU2::pau2_fure               , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 282
+    {pau2_pau4_fure         , "pau2_pau4_fure"          , 0x1203200F, PAU2::pau2_pau4_fure          , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 283
+    {pau2_pau5_fure         , "pau2_pau5_fure"          , 0x1203100F, PAU2::pau2_pau5_fure          , PAU2_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 284
+    {pau3_fure              , "pau3_fure"               , 0x1303430F, PAU3::pau3_fure               , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 285
+    {pau3_pau6_fure         , "pau3_pau6_fure"          , 0x1303200F, PAU3::pau3_pau6_fure          , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 286
+    {pau3_pau7_fure         , "pau3_pau7_fure"          , 0x1303100F, PAU3::pau3_pau7_fure          , PAU3_TYPE , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 287
+    {iohs0_fure             , "iohs0_fure"              , 0x1803600F, AXON0::iohs0_fure             , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 288
+    {iohs0_ndl_fure         , "iohs0_ndl_fure"          , 0x1803040F, AXON0::iohs0_ndl_fure         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 289
+    {iohs0_pdl_fure         , "iohs0_pdl_fure"          , 0x1803020F, AXON0::iohs0_pdl_fure         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 290
+    {iohs0_pll_func         , "iohs0_pll_func"          , 0x18030010, AXON0::iohs0_pll_func         , AXON0_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 291
+    {iohs0_pll_bndy         , "iohs0_pll_bndy"          , 0x18030018, AXON0::iohs0_pll_bndy         , AXON0_TYPE, RMRK_ROOT | RMRK_HAS_DERIVS | RCLS_EKB_RINGS             }, // 292
+    {iohs0_pll_bndy_bucket_0, "iohs0_pll_bndy_bucket_0" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_0, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 293
+    {iohs0_pll_bndy_bucket_1, "iohs0_pll_bndy_bucket_1" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_1, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 294
+    {iohs0_pll_bndy_bucket_2, "iohs0_pll_bndy_bucket_2" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_2, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 295
+    {iohs0_pll_bndy_bucket_3, "iohs0_pll_bndy_bucket_3" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_3, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 296
+    {iohs0_pll_bndy_bucket_4, "iohs0_pll_bndy_bucket_4" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_4, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 297
+    {iohs0_pll_bndy_bucket_5, "iohs0_pll_bndy_bucket_5" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_5, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 298
+    {iohs0_pll_bndy_bucket_6, "iohs0_pll_bndy_bucket_6" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_6, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 299
+    {iohs0_pll_bndy_bucket_7, "iohs0_pll_bndy_bucket_7" , 0x18030018, AXON0::iohs0_pll_bndy_bucket_7, AXON0_TYPE, RCLS_EKB_RINGS                                       }, // 300
+    {iohs1_fure             , "iohs1_fure"              , 0x1903600F, AXON1::iohs1_fure             , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 301
+    {iohs1_ndl_fure         , "iohs1_ndl_fure"          , 0x1903040F, AXON1::iohs1_ndl_fure         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 302
+    {iohs1_pdl_fure         , "iohs1_pdl_fure"          , 0x1903020F, AXON1::iohs1_pdl_fure         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 303
+    {iohs1_pll_func         , "iohs1_pll_func"          , 0x19030010, AXON1::iohs1_pll_func         , AXON1_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 304
+    {iohs2_fure             , "iohs2_fure"              , 0x1A03600F, AXON2::iohs2_fure             , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 305
+    {iohs2_ndl_fure         , "iohs2_ndl_fure"          , 0x1A03040F, AXON2::iohs2_ndl_fure         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 306
+    {iohs2_pdl_fure         , "iohs2_pdl_fure"          , 0x1A03020F, AXON2::iohs2_pdl_fure         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 307
+    {iohs2_pll_func         , "iohs2_pll_func"          , 0x1A030010, AXON2::iohs2_pll_func         , AXON2_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 308
+    {iohs3_fure             , "iohs3_fure"              , 0x1B03600F, AXON3::iohs3_fure             , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 309
+    {iohs3_ndl_fure         , "iohs3_ndl_fure"          , 0x1B03040F, AXON3::iohs3_ndl_fure         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 310
+    {iohs3_pdl_fure         , "iohs3_pdl_fure"          , 0x1B03020F, AXON3::iohs3_pdl_fure         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 311
+    {iohs3_pll_func         , "iohs3_pll_func"          , 0x1B030010, AXON3::iohs3_pll_func         , AXON3_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 312
+    {iohs4_fure             , "iohs4_fure"              , 0x1C03600F, AXON4::iohs4_fure             , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 313
+    {iohs4_ndl_fure         , "iohs4_ndl_fure"          , 0x1C03040F, AXON4::iohs4_ndl_fure         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 314
+    {iohs4_pdl_fure         , "iohs4_pdl_fure"          , 0x1C03020F, AXON4::iohs4_pdl_fure         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 315
+    {iohs4_pll_func         , "iohs4_pll_func"          , 0x1C030010, AXON4::iohs4_pll_func         , AXON4_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 316
+    {iohs5_fure             , "iohs5_fure"              , 0x1D03600F, AXON5::iohs5_fure             , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 317
+    {iohs5_ndl_fure         , "iohs5_ndl_fure"          , 0x1D03040F, AXON5::iohs5_ndl_fure         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 318
+    {iohs5_pdl_fure         , "iohs5_pdl_fure"          , 0x1D03020F, AXON5::iohs5_pdl_fure         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 319
+    {iohs5_pll_func         , "iohs5_pll_func"          , 0x1D030010, AXON5::iohs5_pll_func         , AXON5_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 320
+    {iohs6_fure             , "iohs6_fure"              , 0x1E03600F, AXON6::iohs6_fure             , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 321
+    {iohs6_ndl_fure         , "iohs6_ndl_fure"          , 0x1E03040F, AXON6::iohs6_ndl_fure         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 322
+    {iohs6_pdl_fure         , "iohs6_pdl_fure"          , 0x1E03020F, AXON6::iohs6_pdl_fure         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 323
+    {iohs6_pll_func         , "iohs6_pll_func"          , 0x1E030010, AXON6::iohs6_pll_func         , AXON6_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 324
+    {iohs7_fure             , "iohs7_fure"              , 0x1F03600F, AXON7::iohs7_fure             , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 325
+    {iohs7_ndl_fure         , "iohs7_ndl_fure"          , 0x1F03040F, AXON7::iohs7_ndl_fure         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 326
+    {iohs7_pdl_fure         , "iohs7_pdl_fure"          , 0x1F03020F, AXON7::iohs7_pdl_fure         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 327
+    {iohs7_pll_func         , "iohs7_pll_func"          , 0x1F030010, AXON7::iohs7_pll_func         , AXON7_TYPE, RMRK_ROOT | RCLS_EKB_RINGS                             }, // 328
+    {eq_fure                , "eq_fure"                 , 0x2003402F, EQ::eq_fure                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 329
+    {eq_cmsk                , "eq_cmsk"                 , 0x2003402A, EQ::eq_cmsk                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 330
+    {eq_inex                , "eq_inex"                 , 0x2003402B, EQ::eq_inex                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 331
+    {eq_mode                , "eq_mode"                 , 0x20034021, EQ::eq_mode                   , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 332
+    {eq_clkadj_fure         , "eq_clkadj_fure"          , 0x2003001F, EQ::eq_clkadj_fure            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 333
+    {eq_clkadj_cmsk         , "eq_clkadj_cmsk"          , 0x2003001A, EQ::eq_clkadj_cmsk            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 334
+    {eq_clkadj_inex         , "eq_clkadj_inex"          , 0x2003001B, EQ::eq_clkadj_inex            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 335
+    {eq_clkadj_mode         , "eq_clkadj_mode"          , 0x20030011, EQ::eq_clkadj_mode            , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                             }, // 336
+    {ec_cl2_fure            , "ec_cl2_fure"             , 0x2003200F, EQ::ec_cl2_fure               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 337
+    {ec_cl2_cmsk            , "ec_cl2_cmsk"             , 0x2003200A, EQ::ec_cl2_cmsk               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 338
+    {ec_cl2_inex            , "ec_cl2_inex"             , 0x2003200B, EQ::ec_cl2_inex               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 339
+    {ec_cl2_mode            , "ec_cl2_mode"             , 0x20032001, EQ::ec_cl2_mode               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 340
+    {ec_mma_fure            , "ec_mma_fure"             , 0x2083000F, EQ::ec_mma_fure               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 341
+    {ec_mma_cmsk            , "ec_mma_cmsk"             , 0x2083000A, EQ::ec_mma_cmsk               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 342
+    {ec_mma_inex            , "ec_mma_inex"             , 0x2083000B, EQ::ec_mma_inex               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 343
+    {ec_l3_fure             , "ec_l3_fure"              , 0x2003020F, EQ::ec_l3_fure                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 344
+    {ec_l3_cmsk             , "ec_l3_cmsk"              , 0x2003020A, EQ::ec_l3_cmsk                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 345
+    {ec_l3_inex             , "ec_l3_inex"              , 0x2003020B, EQ::ec_l3_inex                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 346
+    {ec_l3_mode             , "ec_l3_mode"              , 0x20030201, EQ::ec_l3_mode                , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS | RMRK_SCAN_BY_QME            }, // 347
+    {n0_abst                , "n0_abst"                 , 0x02036405, N0::n0_abst                   , N0_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                               }, // 348
+    {n1_abst                , "n1_abst"                 , 0x03035405, N1::n1_abst                   , N1_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                               }, // 349
+    {n1_nmmu1_abst          , "n1_nmmu1_abst"           , 0x03030205, N1::n1_nmmu1_abst             , N1_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                               }, // 350
+    {ec_cl2_abst            , "ec_cl2_abst"             , 0x20032005, EQ::ec_cl2_abst               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                               }, // 351
+    {ec_mma_abst            , "ec_mma_abst"             , 0x20830005, EQ::ec_mma_abst               , EQ_TYPE   , RMRK_ROOT | RCLS_EKB_RINGS                               }, // 352
 };
 #endif
 
@@ -1030,103 +1039,103 @@ static const RingProperties_t RING_PROPERTIES[NUM_RING_IDS] =
     {EQ::ec3_l3_repr               , EQ_TYPE   }, // 160
 
     // EKB Rings:
-    {PERV::perv_fure               , PERV_TYPE }, // 161
-    {PERV::sbe_fure                , PERV_TYPE }, // 162
-    {PERV::occ_fure                , PERV_TYPE }, // 163
-    {PERV::perv_dpll_func          , PERV_TYPE }, // 164
-    {PERV::perv_dpll_bndy          , PERV_TYPE }, // 165
-    {PERV::perv_dpll_time          , PERV_TYPE }, // 166
-    {PERV::perv_pll_func           , PERV_TYPE }, // 167
-    {PERV::perv_pll_bndy           , PERV_TYPE }, // 168
-    {N0::n0_fure                   , N0_TYPE   }, // 169
-    {N1::n1_fure                   , N1_TYPE   }, // 170
-    {N1::n1_nmmu1_fure             , N1_TYPE   }, // 171
-    {PCI::pci_fure                 , PCI_TYPE  }, // 172
-    {PCI::pci_pll_func             , PCI_TYPE  }, // 173
-    {PCI::pci_pll_bndy             , PCI_TYPE  }, // 174
-    {MC::mc_fure                   , MC_TYPE   }, // 175
-    {MC::mc_pll_func               , MC_TYPE   }, // 176
-    {MC::mc_pll_bndy               , MC_TYPE   }, // 177
-    {MC::mc_pll_bndy_bucket_0      , MC_TYPE   }, // 178
-    {MC::mc_pll_bndy_bucket_1      , MC_TYPE   }, // 179
-    {MC::mc_pll_bndy_bucket_2      , MC_TYPE   }, // 180
-    {MC::mc_pll_bndy_bucket_3      , MC_TYPE   }, // 181
-    {MC::mc_pll_bndy_bucket_4      , MC_TYPE   }, // 182
-    {PAU0::pau0_fure               , PAU0_TYPE }, // 183
-    {PAU0::pau0_pau0_fure          , PAU0_TYPE }, // 184
-    {PAU1::pau1_fure               , PAU1_TYPE }, // 185
-    {PAU1::pau1_pau3_fure          , PAU1_TYPE }, // 186
-    {PAU2::pau2_fure               , PAU2_TYPE }, // 187
-    {PAU2::pau2_pau4_fure          , PAU2_TYPE }, // 188
-    {PAU2::pau2_pau5_fure          , PAU2_TYPE }, // 189
-    {PAU3::pau3_fure               , PAU3_TYPE }, // 190
-    {PAU3::pau3_pau6_fure          , PAU3_TYPE }, // 191
-    {PAU3::pau3_pau7_fure          , PAU3_TYPE }, // 192
-    {AXON0::iohs0_fure             , AXON0_TYPE}, // 193
-    {AXON0::iohs0_ndl_fure         , AXON0_TYPE}, // 194
-    {AXON0::iohs0_pdl_fure         , AXON0_TYPE}, // 195
-    {AXON0::iohs0_pll_func         , AXON0_TYPE}, // 196
-    {AXON0::iohs0_pll_bndy         , AXON0_TYPE}, // 197
-    {AXON0::iohs0_pll_bndy_bucket_0, AXON0_TYPE}, // 198
-    {AXON0::iohs0_pll_bndy_bucket_1, AXON0_TYPE}, // 199
-    {AXON0::iohs0_pll_bndy_bucket_2, AXON0_TYPE}, // 200
-    {AXON0::iohs0_pll_bndy_bucket_3, AXON0_TYPE}, // 201
-    {AXON0::iohs0_pll_bndy_bucket_4, AXON0_TYPE}, // 202
-    {AXON0::iohs0_pll_bndy_bucket_5, AXON0_TYPE}, // 203
-    {AXON0::iohs0_pll_bndy_bucket_6, AXON0_TYPE}, // 204
-    {AXON0::iohs0_pll_bndy_bucket_7, AXON0_TYPE}, // 205
-    {AXON1::iohs1_fure             , AXON1_TYPE}, // 206
-    {AXON1::iohs1_ndl_fure         , AXON1_TYPE}, // 207
-    {AXON1::iohs1_pdl_fure         , AXON1_TYPE}, // 208
-    {AXON1::iohs1_pll_func         , AXON1_TYPE}, // 209
-    {AXON2::iohs2_fure             , AXON2_TYPE}, // 210
-    {AXON2::iohs2_ndl_fure         , AXON2_TYPE}, // 211
-    {AXON2::iohs2_pdl_fure         , AXON2_TYPE}, // 212
-    {AXON2::iohs2_pll_func         , AXON2_TYPE}, // 213
-    {AXON3::iohs3_fure             , AXON3_TYPE}, // 214
-    {AXON3::iohs3_ndl_fure         , AXON3_TYPE}, // 215
-    {AXON3::iohs3_pdl_fure         , AXON3_TYPE}, // 216
-    {AXON3::iohs3_pll_func         , AXON3_TYPE}, // 217
-    {AXON4::iohs4_fure             , AXON4_TYPE}, // 218
-    {AXON4::iohs4_ndl_fure         , AXON4_TYPE}, // 219
-    {AXON4::iohs4_pdl_fure         , AXON4_TYPE}, // 220
-    {AXON4::iohs4_pll_func         , AXON4_TYPE}, // 221
-    {AXON5::iohs5_fure             , AXON5_TYPE}, // 222
-    {AXON5::iohs5_ndl_fure         , AXON5_TYPE}, // 223
-    {AXON5::iohs5_pdl_fure         , AXON5_TYPE}, // 224
-    {AXON5::iohs5_pll_func         , AXON5_TYPE}, // 225
-    {AXON6::iohs6_fure             , AXON6_TYPE}, // 226
-    {AXON6::iohs6_ndl_fure         , AXON6_TYPE}, // 227
-    {AXON6::iohs6_pdl_fure         , AXON6_TYPE}, // 228
-    {AXON6::iohs6_pll_func         , AXON6_TYPE}, // 229
-    {AXON7::iohs7_fure             , AXON7_TYPE}, // 230
-    {AXON7::iohs7_ndl_fure         , AXON7_TYPE}, // 231
-    {AXON7::iohs7_pdl_fure         , AXON7_TYPE}, // 232
-    {AXON7::iohs7_pll_func         , AXON7_TYPE}, // 233
-    {EQ::eq_fure                   , EQ_TYPE   }, // 234
-    {EQ::eq_cmsk                   , EQ_TYPE   }, // 235
-    {EQ::eq_inex                   , EQ_TYPE   }, // 236
-    {EQ::eq_mode                   , EQ_TYPE   }, // 237
-    {EQ::eq_clkadj_fure            , EQ_TYPE   }, // 238
-    {EQ::eq_clkadj_cmsk            , EQ_TYPE   }, // 239
-    {EQ::eq_clkadj_inex            , EQ_TYPE   }, // 240
-    {EQ::eq_clkadj_mode            , EQ_TYPE   }, // 241
-    {EQ::ec_cl2_fure               , EQ_TYPE   }, // 242
-    {EQ::ec_cl2_cmsk               , EQ_TYPE   }, // 243
-    {EQ::ec_cl2_inex               , EQ_TYPE   }, // 244
-    {EQ::ec_cl2_mode               , EQ_TYPE   }, // 245
-    {EQ::ec_mma_fure               , EQ_TYPE   }, // 246
-    {EQ::ec_mma_cmsk               , EQ_TYPE   }, // 247
-    {EQ::ec_mma_inex               , EQ_TYPE   }, // 248
-    {EQ::ec_l3_fure                , EQ_TYPE   }, // 249
-    {EQ::ec_l3_cmsk                , EQ_TYPE   }, // 250
-    {EQ::ec_l3_inex                , EQ_TYPE   }, // 251
-    {EQ::ec_l3_mode                , EQ_TYPE   }, // 252
-    {N0::n0_abst                   , N0_TYPE   }, // 253
-    {N1::n1_abst                   , N1_TYPE   }, // 254
-    {N1::n1_nmmu1_abst             , N1_TYPE   }, // 255
-    {EQ::ec_cl2_abst               , EQ_TYPE   }, // 256
-    {EQ::ec_mma_abst               , EQ_TYPE   }, // 257
+    {PERV::perv_fure               , PERV_TYPE }, // 256
+    {PERV::sbe_fure                , PERV_TYPE }, // 257
+    {PERV::occ_fure                , PERV_TYPE }, // 258
+    {PERV::perv_dpll_func          , PERV_TYPE }, // 259
+    {PERV::perv_dpll_bndy          , PERV_TYPE }, // 260
+    {PERV::perv_dpll_time          , PERV_TYPE }, // 261
+    {PERV::perv_pll_func           , PERV_TYPE }, // 262
+    {PERV::perv_pll_bndy           , PERV_TYPE }, // 263
+    {N0::n0_fure                   , N0_TYPE   }, // 264
+    {N1::n1_fure                   , N1_TYPE   }, // 265
+    {N1::n1_nmmu1_fure             , N1_TYPE   }, // 266
+    {PCI::pci_fure                 , PCI_TYPE  }, // 267
+    {PCI::pci_pll_func             , PCI_TYPE  }, // 268
+    {PCI::pci_pll_bndy             , PCI_TYPE  }, // 269
+    {MC::mc_fure                   , MC_TYPE   }, // 270
+    {MC::mc_pll_func               , MC_TYPE   }, // 271
+    {MC::mc_pll_bndy               , MC_TYPE   }, // 272
+    {MC::mc_pll_bndy_bucket_0      , MC_TYPE   }, // 273
+    {MC::mc_pll_bndy_bucket_1      , MC_TYPE   }, // 274
+    {MC::mc_pll_bndy_bucket_2      , MC_TYPE   }, // 275
+    {MC::mc_pll_bndy_bucket_3      , MC_TYPE   }, // 276
+    {MC::mc_pll_bndy_bucket_4      , MC_TYPE   }, // 277
+    {PAU0::pau0_fure               , PAU0_TYPE }, // 278
+    {PAU0::pau0_pau0_fure          , PAU0_TYPE }, // 279
+    {PAU1::pau1_fure               , PAU1_TYPE }, // 280
+    {PAU1::pau1_pau3_fure          , PAU1_TYPE }, // 281
+    {PAU2::pau2_fure               , PAU2_TYPE }, // 282
+    {PAU2::pau2_pau4_fure          , PAU2_TYPE }, // 283
+    {PAU2::pau2_pau5_fure          , PAU2_TYPE }, // 284
+    {PAU3::pau3_fure               , PAU3_TYPE }, // 285
+    {PAU3::pau3_pau6_fure          , PAU3_TYPE }, // 286
+    {PAU3::pau3_pau7_fure          , PAU3_TYPE }, // 287
+    {AXON0::iohs0_fure             , AXON0_TYPE}, // 288
+    {AXON0::iohs0_ndl_fure         , AXON0_TYPE}, // 289
+    {AXON0::iohs0_pdl_fure         , AXON0_TYPE}, // 290
+    {AXON0::iohs0_pll_func         , AXON0_TYPE}, // 291
+    {AXON0::iohs0_pll_bndy         , AXON0_TYPE}, // 292
+    {AXON0::iohs0_pll_bndy_bucket_0, AXON0_TYPE}, // 293
+    {AXON0::iohs0_pll_bndy_bucket_1, AXON0_TYPE}, // 294
+    {AXON0::iohs0_pll_bndy_bucket_2, AXON0_TYPE}, // 295
+    {AXON0::iohs0_pll_bndy_bucket_3, AXON0_TYPE}, // 296
+    {AXON0::iohs0_pll_bndy_bucket_4, AXON0_TYPE}, // 297
+    {AXON0::iohs0_pll_bndy_bucket_5, AXON0_TYPE}, // 298
+    {AXON0::iohs0_pll_bndy_bucket_6, AXON0_TYPE}, // 299
+    {AXON0::iohs0_pll_bndy_bucket_7, AXON0_TYPE}, // 300
+    {AXON1::iohs1_fure             , AXON1_TYPE}, // 301
+    {AXON1::iohs1_ndl_fure         , AXON1_TYPE}, // 302
+    {AXON1::iohs1_pdl_fure         , AXON1_TYPE}, // 303
+    {AXON1::iohs1_pll_func         , AXON1_TYPE}, // 304
+    {AXON2::iohs2_fure             , AXON2_TYPE}, // 305
+    {AXON2::iohs2_ndl_fure         , AXON2_TYPE}, // 306
+    {AXON2::iohs2_pdl_fure         , AXON2_TYPE}, // 307
+    {AXON2::iohs2_pll_func         , AXON2_TYPE}, // 308
+    {AXON3::iohs3_fure             , AXON3_TYPE}, // 309
+    {AXON3::iohs3_ndl_fure         , AXON3_TYPE}, // 310
+    {AXON3::iohs3_pdl_fure         , AXON3_TYPE}, // 311
+    {AXON3::iohs3_pll_func         , AXON3_TYPE}, // 312
+    {AXON4::iohs4_fure             , AXON4_TYPE}, // 313
+    {AXON4::iohs4_ndl_fure         , AXON4_TYPE}, // 314
+    {AXON4::iohs4_pdl_fure         , AXON4_TYPE}, // 315
+    {AXON4::iohs4_pll_func         , AXON4_TYPE}, // 316
+    {AXON5::iohs5_fure             , AXON5_TYPE}, // 317
+    {AXON5::iohs5_ndl_fure         , AXON5_TYPE}, // 318
+    {AXON5::iohs5_pdl_fure         , AXON5_TYPE}, // 319
+    {AXON5::iohs5_pll_func         , AXON5_TYPE}, // 320
+    {AXON6::iohs6_fure             , AXON6_TYPE}, // 321
+    {AXON6::iohs6_ndl_fure         , AXON6_TYPE}, // 322
+    {AXON6::iohs6_pdl_fure         , AXON6_TYPE}, // 323
+    {AXON6::iohs6_pll_func         , AXON6_TYPE}, // 324
+    {AXON7::iohs7_fure             , AXON7_TYPE}, // 325
+    {AXON7::iohs7_ndl_fure         , AXON7_TYPE}, // 326
+    {AXON7::iohs7_pdl_fure         , AXON7_TYPE}, // 327
+    {AXON7::iohs7_pll_func         , AXON7_TYPE}, // 328
+    {EQ::eq_fure                   , EQ_TYPE   }, // 329
+    {EQ::eq_cmsk                   , EQ_TYPE   }, // 330
+    {EQ::eq_inex                   , EQ_TYPE   }, // 331
+    {EQ::eq_mode                   , EQ_TYPE   }, // 332
+    {EQ::eq_clkadj_fure            , EQ_TYPE   }, // 333
+    {EQ::eq_clkadj_cmsk            , EQ_TYPE   }, // 334
+    {EQ::eq_clkadj_inex            , EQ_TYPE   }, // 335
+    {EQ::eq_clkadj_mode            , EQ_TYPE   }, // 336
+    {EQ::ec_cl2_fure               , EQ_TYPE   }, // 337
+    {EQ::ec_cl2_cmsk               , EQ_TYPE   }, // 338
+    {EQ::ec_cl2_inex               , EQ_TYPE   }, // 339
+    {EQ::ec_cl2_mode               , EQ_TYPE   }, // 340
+    {EQ::ec_mma_fure               , EQ_TYPE   }, // 341
+    {EQ::ec_mma_cmsk               , EQ_TYPE   }, // 342
+    {EQ::ec_mma_inex               , EQ_TYPE   }, // 343
+    {EQ::ec_l3_fure                , EQ_TYPE   }, // 344
+    {EQ::ec_l3_cmsk                , EQ_TYPE   }, // 345
+    {EQ::ec_l3_inex                , EQ_TYPE   }, // 346
+    {EQ::ec_l3_mode                , EQ_TYPE   }, // 347
+    {N0::n0_abst                   , N0_TYPE   }, // 348
+    {N1::n1_abst                   , N1_TYPE   }, // 349
+    {N1::n1_nmmu1_abst             , N1_TYPE   }, // 350
+    {EQ::ec_cl2_abst               , EQ_TYPE   }, // 351
+    {EQ::ec_mma_abst               , EQ_TYPE   }, // 352
 };
 #endif  // __PPE__
 
diff --git a/src/import/chips/p10/utils/imageProcs/p10_tor.C b/src/import/chips/p10/utils/imageProcs/p10_tor.C
index 2a5009a..c89c707 100644
--- a/src/import/chips/p10/utils/imageProcs/p10_tor.C
+++ b/src/import/chips/p10/utils/imageProcs/p10_tor.C
@@ -60,6 +60,7 @@ int _tor_access_ring( void*          io_ringSection,   // Ring section ptr
     TorOffset_t       ringOffset16; // Offset to actual ring container (for PUT operation)
     uint32_t          torSlotNum; // TOR slot number (within a chiplet section)
     uint32_t          rs4Size;    // Size of RS4 ring container/block.
+    RingId_t          rpIndex = UNDEFINED_RING_ID;
     RingId_t          numRings;
     ChipletType_t     chipletType = UNDEFINED_CHIPLET_TYPE;
     ChipletType_t     chipletIndex = UNDEFINED_CHIPLET_TYPE; // Effective chiplet index
@@ -85,7 +86,13 @@ int _tor_access_ring( void*          io_ringSection,   // Ring section ptr
         return rc;
     }
 
-    chipletType = ringProps[i_ringId].chipletType;
+    // Get the ring properties (rp) index
+    rpIndex = ringid_convert_ringId_to_rpIndex(i_ringId);
+
+    // Note:  Prior to entering _tor_access_ring(), we must call _tor_header_check()
+    //        which also verifies valid ringId.  So no need to check ringId again.
+
+    chipletType = ringProps[rpIndex].chipletType;
 
     //
     // Get all other metadata for the chipletType
@@ -131,7 +138,7 @@ int _tor_access_ring( void*          io_ringSection,   // Ring section ptr
     //
     // Determine whether Common or Instance section based on the INSTANCE_RING_MARK
     //
-    if ( ringProps[i_ringId].idxRing & INSTANCE_RING_MARK )
+    if ( ringProps[rpIndex].idxRing & INSTANCE_RING_MARK )
     {
         bInstCase = 1;
     }
@@ -144,7 +151,7 @@ int _tor_access_ring( void*          io_ringSection,   // Ring section ptr
                    chipletData->numInstanceRings :
                    chipletData->numCommonRings;
 
-    idxRingEff   = ringProps[i_ringId].idxRing & INSTANCE_RING_MASK; // Always safe
+    idxRingEff   = ringProps[rpIndex].idxRing & INSTANCE_RING_MASK; // Always safe
 
     //
     // Check that chipletId is within chiplet's range (Note that we care only about Instance
@@ -371,18 +378,15 @@ int _tor_header_and_ring_check( void*           i_ringSection,  // Ring section
 
     if ( rc != TOR_SUCCESS )
     {
-        if ( rc == TOR_HOLE_RING_ID )
-        {
-            // "hole" ring. Not an error. No info to retrieve.
-            return rc;
-        }
-        else if ( rc == TOR_INVALID_RING_ID || rc == TOR_INVALID_CHIP_ID )
+        // Only trace out what we know could be an error.
+        if ( rc == TOR_INVALID_CHIP_ID )
         {
-            MY_ERR("ERROR: TOR ringId check: ringid_check_ringId() failed w/rc=0x%08x\n"
-                   " So either invalid ringId(=0x%x) or invalid chipId(=0x%x)\n",
-                   rc, i_ringId, torHeader->chipId);
-            return rc;
+            MY_ERR("ERROR: TOR ringId check: ringid_check_ringId() failed w/rc=0x%08x"
+                   " which is an invalid chipId(=0x%x)\n",
+                   rc, torHeader->chipId);
         }
+
+        return rc;
     }
 
     // Check TOR header
@@ -438,12 +442,18 @@ int tor_get_single_ring ( void*         i_ringSection,  // Ring section ptr
                                      i_dbgl );
 
     // Explanation to the "list" of RCs that we exclude from tracing out:
-    // TOR_HOLE_RING_ID:   Normal scenario when rings are removed from the ring list
-    if ( rc &&
-         rc != TOR_HOLE_RING_ID )
+    // TOR_HOLE_RING_ID:    Can happen if a ring has been removed from the ring list
+    // TOR_INVALID_RING_ID: CAn happen if caller carelessly cycles through ringIds
+    if ( rc )
     {
-        MY_ERR("ERROR: tor_get_single_ring(): _tor_header_and_ring_check() failed w/rc=0x%08x\n",
-               rc);
+        if ( rc != TOR_HOLE_RING_ID &&
+             rc != TOR_INVALID_RING_ID )
+        {
+            MY_ERR("ERROR: tor_get_single_ring: _tor_header_and_ring_check() failed"
+                   " w/rc=0x%08x\n",
+                   rc);
+        }
+
         return rc;
     }
 
@@ -458,8 +468,6 @@ int tor_get_single_ring ( void*         i_ringSection,  // Ring section ptr
 
     // Explanation to the "list" of RCs that we exclude from tracing out:
     // TOR_RING_IS_EMPTY:  Normal scenario (will occur frequently).
-    // TOR_HOLE_RING_ID:   Normal scenario when rings are removed from the ring list
-    //                     and leaves behind a "hole".
     // TOR_RING_HAS_NO_TOR_SLOT:  Will be caused a lot by ipl_image_tool, but is an error if
     //                     called by any other user.
     // TOR_INVALID_CHIPLET_ID:  Not necessarily an error as a user may be sweeping through a
@@ -472,13 +480,12 @@ int tor_get_single_ring ( void*         i_ringSection,  // Ring section ptr
     //                     in both ipl_image_tool and ipl_customize (RT_QME phase).
     if ( rc &&
          rc != TOR_RING_IS_EMPTY &&
-         rc != TOR_HOLE_RING_ID &&
          rc != TOR_RING_HAS_NO_TOR_SLOT &&
          rc != TOR_INVALID_CHIPLET_ID &&
          rc != TOR_INVALID_CHIPLET_TYPE )
     {
-        MY_ERR("ERROR: tor_get_single_ring(): _tor_access_ring() failed w/rc=0x%08x\n", rc);
-
+        MY_ERR("ERROR: tor_get_single_ring: _tor_access_ring() failed w/rc=0x%08x\n",
+               rc);
         return rc;
     }
 
@@ -507,7 +514,7 @@ int tor_append_ring( void*           io_ringSection,       // Ring section ptr
 
     if (rc)
     {
-        MY_ERR("ERROR: tor_append_ring(): _tor_header_and_ring_check() failed w/rc=0x%08x\n",
+        MY_ERR("ERROR: tor_append_ring: _tor_header_and_ring_check() failed w/rc=0x%08x\n",
                rc);
         return rc;
     }
@@ -539,7 +546,7 @@ int tor_append_ring( void*           io_ringSection,       // Ring section ptr
     if ( rc &&
          rc != TOR_INVALID_CHIPLET_TYPE )
     {
-        MY_ERR("ERROR: tor_append_ring(): _tor_access_ring() failed w/rc=0x%08x for"
+        MY_ERR("ERROR: tor_append_ring: _tor_access_ring() failed w/rc=0x%08x for"
                " ringId=0x%x\n",
                rc, i_ringId);
         return rc;
@@ -768,19 +775,15 @@ int dyn_get_ring( void*          i_ringSection,
 
     if ( rc != TOR_SUCCESS )
     {
-        if ( rc == TOR_HOLE_RING_ID )
+        // Only trace out what we know could be an error.
+        if ( rc == TOR_INVALID_CHIP_ID )
         {
-            // "hole" ring. Not an error. No info to retrieve.
-            return rc;
+            MY_ERR("ERROR: dyn_get_ring: ringid_check_ringId() failed w/rc=0x%08x"
+                   " which is an invalid chipId(=0x%x)\n",
+                   rc, torHeader->chipId);
         }
-        else if ( rc == TOR_INVALID_RING_ID || rc == TOR_INVALID_CHIP_ID )
-        {
-            MY_ERR("ERROR: dyn_get_ring(): ringid_check_ringId() failed w/rc=0x%08x\n"
-                   " So either invalid ringId(=0x%x) or invalid chipId(=0x%x)\n",
-                   rc, i_ringId, torHeader->chipId);
 
-            return rc;
-        }
+        return rc;
     }
 
     // TOR header check
@@ -791,7 +794,7 @@ int dyn_get_ring( void*          i_ringSection,
          torHeader->ddLevel != i_ddLevel ||
          torHeader->rtVersion != RING_TABLE_VERSION_HWIMG )
     {
-        MY_ERR("ERROR: dyn_get_ring(): TOR header check failed as follows:\n"
+        MY_ERR("ERROR: dyn_get_ring: TOR header check failed as follows:\n"
                " torHeader->magic(=0x%08x) != TOR_MAGIC_DYN(=0x%08x)\n"
                " torHeader->version(=%u) != TOR_VERSION(=%u)\n"
                " torHeader->ddLevel(=0x%02x) != i_ddLevel(=0x%02x)\n"
-- 
1.8.2.2

